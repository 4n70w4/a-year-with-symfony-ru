## Повторно используемый код должен быть открыт для расширения

Переиспользуемый код должен быть гибок. Пользователь вашего бандла должен иметь возможность настроить
сервисы по-другому, нежели они были настроены в оригинальном проекте, под который вы их разработали.
Он также должен иметь возможность заменить любой сервис бандла своей реализацией и при этом не обрушить
все приложение. Другими словами, переиспользуемый код должен придерживаться принципа "открыт для расширения, 
закрыт для модификации". Нельзя ставить пользователя в ситуацию, когда он будет вынужден лезть в оригинальный
код и патчить его, вместо этого он должен лишь заменять или расширять отдельные его части под свои нужды.

### Настраиваемое поведение

Для того, чтобы ваш бандл был гибким, он должен иметь обширный набор настраиваемых опций с значениями по
умолчанию и информацией о том за что каждая из опций отвечает. Загружаться должны лишь те сервисы, которые
определены посредством этих опций, предоставленных разработчиком (например в config.yml). Подробнее об
этом читайте в разделе [Приёмы внедрения зависимостей](#patterns-of-dependency-injection). Там вы
найдете много советов о том как сделать ваш бандл настраиваемым.

### Все должно быть заменяемым

Используя "проход компилятора" (compiler pass, по этому вопросу также смотрите раздел [Приёмы внедрения зависимостей
](#patterns-of-dependency-injection)) можно заменять любое ранее созданное определение сервиса определением
вашего сервиса или изменить класс или аргумент в существующем определении сервиса. Это означает, что если 
разработчик захочет заменить часть функциональности вашего бандла своей функциональностью, теоретически 
всегда есть способ сделать это. Есть несколько вещей, которые вам нужно сделать для того, чтобы помочь разработчикам
заменять все что они могли бы захотеть заменить, оставляя при этом другие части бандла неизменными.

> #### Много маленьких классов, много отдельных обязанностей
> 
> Возможно вы захотите воспользоваться моим опытом: положим вы попытались воспользоваться неким
> open source бандлом, но вам не нравится часть функций, которые он предоставляет. Вы пытаетесь
> заменить часть этих функций, но количество изменений становится все больше и больше, пока вы
> фактически не разработаете свой собственный бандл. Проблема заключается в том, что в этом
> случае в бандле будет слишком слабое разделение ответственности (см. 
> [о принципе разделения ответственности - “separation of concerns” в википедии](https://ru.wikipedia.org/wiki/Разделение_ответственности)):
> некоторые громоздкие классы будут стараються делать слишком много вещей. Из такой ситуации можно сделать 
> следующие выводы:
> 
> - Создавайте много мелких классов, с несколькими методами и одной ответственностью (см. также [принцип единой ответственности](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности))
> - Создавайте сервисы на базе этих маленьких классов

#### Use lots of interfaces

Define lots of interfaces for the classes that you use, both in your bundle and in the corresponding
library code. Interfaces are literally the contracts that are signed between one object and another. A
class that implements an interface says: don’t worry about how I do things exactly, this is how you
can talk to me.

A traditional example, using only classes:

{lang="php"}
~~~~~~~~~~~~
class Translator
{
    public function trans($id, array $parameters = array())
    {
        ...
    }

    ... lots of other methods
}

class TranslationExtension
{
    private $translator;

    public function __construct(Translator $translator)
    {
        $this->translator = $translator;
    }

    public function trans($id, array $parameters = array())
    {
        return $this->translator->trans($id, $parameters);
    }
}
~~~~~~~~~~~~

It has this service definition:

{lang="xml"}
~~~~~~~~~~~~
<service id="translator" class="...">
</service>

<service id="twig.extension.trans" class="...">
    <argument type="service" id="translator" />
</service>
~~~~~~~~~~~~

When a developer wants to replace the translator, he needs to extend from the existing
Translator class to satisfy the constructor argument type-hinted Translator:

{lang="php+xml"}
~~~~~~~~~~~~
class MyTranslator extends Translator
{
    ...
}

<service id="my_translator" class="MyTranslator">
</service>
~~~~~~~~~~~~

But now MyTranslator inherits everything that is already in the Translator class, even though
it is going to do things very differently.

A much better solution would be to define an interface for translators:

{lang="php"}
~~~~~~~~~~~~
interface TranslatorInterface
{
    public function trans($id, array $parameters = array());
}
~~~~~~~~~~~~

The only thing a replacement translator has to do, is implement this interface:

{lang="php"}
~~~~~~~~~~~~
class MyTranslator implements TranslatorInterface
{
    public function trans($id, array $parameters = array())
    {
        // do things very differently
        ...
    }
}
~~~~~~~~~~~~

Finally, any existing type-hints should be changed from Translator to TranslatorInterface:

{lang="php"}
~~~~~~~~~~~~
class TranslationExtension
{
    public function __construct(TranslatorInterface $translator)
    {
        ...
    }
}
~~~~~~~~~~~~

And now nothing stands in the way of replacing the existing translator service with the my_-
translator service, either removing the existing definition, adding a new definition, by changing
the class of the existing definition or by defining an alias from translator to my_translator.

> #### Cohesive interfaces
> 
> When trying to find out what methods really belong to an interface, strive for a coherent set
> of methods, that would definitely belong to any (future) class that implements the interface.

#### Use the bundle configuration to replace services

As I mentioned before, you could in theory replace everything there is in the service container by
something you created yourself. There are many ways to do this. But they are all not so clean and
they won’t be good for maintainability. The best way I’ve seen so far is to allow other developers to
replace specific services, by providing service ids through the bundle configuration:

{lang="php"}
~~~~~~~~~~~~
# in /app/config/config.yml
matthias_message:
    # point to a specific service that should be used
    message_domain_manager: matthias_project.message_domain_manager
~~~~~~~~~~~~

### Add extension points

You can make behavior configurable, or allow others to replace parts of your bundle. But you can
also add ways to extend the behavior of your bundle.

#### Service tags

One way to allow other bundles in an application to extend the behavior of your bundle, is to make
use of service tags. You could think of the way you can register form types that can be used in the
entire application:

{lang="xml"}
~~~~~~~~~~~~
<service id="address_type" class="...">
    <tag name="form.type" alias="address" />
</service>
~~~~~~~~~~~~

Using a compiler pass you can find all services with a given tag and do whatever you want with
them. See also Service tags for implementation details and more examples.

#### Events

Events are great for allowing other parts of an application to hook into the execution of your bundle’s
code. You could use events to simply notify the system that something has happened:

{lang="php"}
~~~~~~~~~~~~
$eventDispatcher->dispatch(
    'matthias_account.account_created',
    new AccountEvent($account)
);
~~~~~~~~~~~~

Or you could use an event object to let other parts of the application modify (filter) some value,
like the Symfony kernel itself does, when it dispatches its kernel events (see also Early response).
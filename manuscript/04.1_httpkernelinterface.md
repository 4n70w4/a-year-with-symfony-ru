## 1 HttpKernelInterface

Symfony is famous for its HttpKernelInterface:

```php
namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;

    /**
     * @return Response
     */
    public function handle(
        Request $request,
        $type = self::MASTER_REQUEST,
        $catch = true
    );
}
```

An implementation of this interface would only have to implement one method and thereby
declare itself capable of converting in some way a given Request into a Response. When you take a
look at any of the front controllers in the /web directory of a Symfony project, you can see that this
handle() method plays a central role in processing web requests - as you might expect:
1 // in /web/app.php
2 $kernel = new AppKernel('prod', false);
3 $request = Request::createFromGlobals();
4 $response = $kernel->handle($request);
5 $response->send();
First, AppKernel gets instantiated. This is a class specific to your project, and you can find it in
/app/AppKernel.php. It allows you to register your bundles, and to change some major settings, like
the location of the cache directory or the configuration file that should be loaded. Its constructor
arguments are the name of the environment and whether or not the kernel should run in debug
mode.
The HttpKernelInterface 3
Environment
The environment can be any string. It is mainly a way to determine which configuration
file should be loaded (e.g. config_dev.yml or config_prod.yml). This is made explicit in
AppKernel:
1 public function registerContainerConfiguration(LoaderInterface $loader)
2 {
3 $loader
4 ->load(__DIR__.'/config/config_'.$this->getEnvironment().'.yml');
5 }
Debug mode
In debug mode you will have:
• A pretty, verbose exception page, showing all the required information for debugging problems.
• Verbose error messages in case the pretty exception page could not be rendered.
• Elaborate information about the time required to run different parts of the application (bootstrapping, database calls, template rendering, etc.).
• Extensive information about requests (using the web profiler and the accompanying
toolbar).
• Automatic cache invalidation: this makes sure that changes to config.yml,
routing.yml and the likes will be taken into account without recompiling the entire
service container or routing matcher for each request (which would take a lot of
time).
Next a Request object is created based on the existing PHP superglobals ($_GET, $_POST, $_-
COOKIE, $_FILES and $_SERVER). The Request class together with other classes from the HttpFoundation
component provide object-oriented ways to wrap the superglobals. These classes also cover many
corner cases you may experience with different versions of PHP or on different platforms. It is wise
(in a Symfony context) to always use Request to retrieve any data you would normally have taken
directly from the superglobals.
Then the handle() method of the AppKernel instance gets called. Its only argument is the current
Request object. The default arguments for the type of the request (“master”) and whether or not to
catch and handle exceptions (yes) will be added automatically.
The result of this handle() method is guaranteed to be an instance of Response (also from the
HttpFoundation component). Finally the response will be sent back to the client that made the
request - for instance a browser.
The HttpKernelInterface 4
1.1 Booting the kernel
Of course, the magic happens inside the handle() method of the kernel. You will find this method
implemented in the Kernel class, which is the parent class of AppKernel:
1 // in Symfony\Component\HttpKernel\Kernel
2 3
public function handle(
4 Request $request,
5 $type = HttpKernelInterface::MASTER_REQUEST,
6 $catch = true
7 ) {
8 if (false === $this->booted) {
9 $this->boot();
10 }
11
12 return $this->getHttpKernel()->handle($request, $type, $catch);
13 }
First of all, it is made sure that the Kernel is booted, before the HttpKernel is asked to do the
rest. The process of booting includes:
• Initializing all the registered bundles
• Initializing the service container
Bundles as container extensions
Bundles are known amongst Symfony developers as the place to put your own code. Each bundle
should have a name that reflects what kind of things you could do with the code inside it. For
instance you may have a BlogBundle, a CommunityBundle, a CommentBundle, etc. You register your
bundles in AppKernel.php, by adding them to the existing list of bundles:
1 class AppKernel extends Kernel
2 {
3 public function registerBundles()
4 {
5 $bundles = array(
6 new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
7 ...,
8 new Matthias\BlogBundle()
9 );
10
11 return $bundles;
12 }
13 }
The HttpKernelInterface 5
This is definitely a good idea - it allows you to plug functionality into and out of your project
with a single line of code. However, when looking at the Kernel and how it deals with all bundles,
including yours, it becomes apparent that bundles are mainly treated as ways to extend the service
container, not as libraries of code. This is why you find a DependencyInjection folder inside many
bundles, accompanied by a {nameOfTheBundle}Extension class. During the process of initializing
the service container, each bundle is allowed to register some services of its own to the service
container, maybe add some parameters too, and possibly modify some service definitions before the
container gets compiled and dumped to the cache directory:
1 namespace Matthias\BlogBundle\DependencyInjection;
2 3
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
4 use Symfony\Component\Config\FileLocator;
5 use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
6 7
class MatthiasBlogExtension extends Extension
8 {
9 public function load(array $configs, ContainerBuilder $container)
10 {
11 $loader = new XmlFileLoader($container,
12 new FileLocator(__DIR__.'/../Resources/config'));
13
14 // add service definitions to the container
15 $loader->load('services.xml');
16
17 $processedConfig = $this->processConfiguration(
18 new Configuration(),
19 $configs
20 );
21
22 // set a parameter
23 $container->setParameter(
24 'matthias_blog.comments_enabled',
25 $processedConfig['enable_comments']
26 );
27 }
28
29 public function getAlias()
30 {
31 return 'matthias_blog';
32 }
33 }
The HttpKernelInterface 6
The name returned by the getAlias() method of a container extension is actually the key under
which you can set configuration values (for instance in config.yml):
1 matthias_blog:
2 enable_comments: true
You will read more about bundle configuration in Patterns of dependency injection.
Every configuration key corresponds to a bundle
In the example above you saw that matthias_blog is the configuration key for settings
related to the MatthiasBlogBundle. It may now not be such a big surprise that this is true
for all keys you may know from config.yml and the likes: values under framework are
related to the FrameworkBundle and values under security (even though they are defined
in a separate file called security.yml) are related to the SecurityBundle. Simple as that!
Creating the service container
After all the bundles have been enabled to add their services and parameters, the container is
finalized in a process that is called “compilation”. During this process it is still possible to make some
last-minute changes to service definitions or parameters. It is also the right moment to validate and
optimize service definitions. Afterwards, the container is in its final form, and it gets dumped into
two different formats: an XML file of all resolved definitions and parameters and a PHP file ready
to be used as the one and only service container in your application.
Both files can be found in the cache directory corresponding to the environment of the kernel, for
instance /app/cache/dev/appDevDebugProjectContainer.xml. The XML file looks like any regular
XML service definition file, only a lot bigger:
1 <service id="event_dispatcher" class="...\ContainerAwareEventDispatcher">
2 <argument type="service" id="service_container"/>
3 <call method="addListenerService">
4 <argument>kernel.controller</argument>
5 ...
6 </call>
7 ...
8 </service>
The PHP file contains a method for each service that can be requested. Any creation logic, like
controller arguments or method calls after instantiation can be found in this file, and it is therefore
the perfect place to debug your service definitions in case anything appears to be wrong with them:
The HttpKernelInterface 7
1 class appDevDebugProjectContainer extends Container
2 {
3 ...
4 5
protected function getEventDispatcherService()
6 {
7 $this->services['event_dispatcher'] =
8 $instance = new ContainerAwareEventDispatcher($this);
9
10 $instance->addListenerService('kernel.controller', ...);
11
12 ...
13
14 return $instance;
15 }
16
17 ...
18 }
1.2 From the Kernel to the HttpKernel
Now that the kernel is booted (i.e. all bundles are initialized, their extensions are registered, and
the service container is finalized), the real handling of the request is delegated to an instance of
HttpKernel:
1 // in Symfony\Component\HttpKernel\Kernel
2 3
public function handle(
4 Request $request,
5 $type = HttpKernelInterface::MASTER_REQUEST,
6 $catch = true
7 ) {
8 if (false === $this->booted) {
9 $this->boot();
10 }
11
12 return $this->getHttpKernel()->handle($request, $type, $catch);
13 }
The HttpKernel implements HttpKernelInterface and it truly knows how to convert a request
to a response. The handle() method looks like this:
The HttpKernelInterface 8
1 public function handle(
2 Request $request,
3 $type = HttpKernelInterface::MASTER_REQUEST,
4 $catch = true
5 ) {
6 try {
7 return $this->handleRaw($request, $type);
8 } catch (\Exception $e) {
9 if (false === $catch) {
10 throw $e;
11 }
12
13 return $this->handleException($e, $request, $type);
14 }
15 }
As you can see, most of the work is done in the private handleRaw() method, and the try/catch
block is here to capture any exceptions. When the initial argument $catch was true (which is the
default value for “master” requests), every exception will be handled nicely. The HttpKernel will try
to find someone who can still create a decent Response object for it (see also Exception handling).
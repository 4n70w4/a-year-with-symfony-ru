## 6 Шаблоны создания сервисов

Сервис - это объект, зарегистрированный в сервисном контейнере с некоторым идентификатором (id), который может быть создан в любой момент через посредством этого контейнера.

### 6.1 Обязательные зависимости

Многие объекты для выполнения своих функций нуждаются в других объектах,  скалярных значениях (например ключ API) и может быть даже в массивах значений (скаляров или объектов). Эти объекты, скаляры и массивы называются зависимостями.
Сначала мы рассмотрим как вы можете определить обязательные зависимости для ваших сервисов.

#### Обязательные параметры конструктора

Самый простой способ передать сервису его зависимости - указать их в качестве аргументов конструктора:

```php
class TokenProvider
{
    private $storage;

    public function __construct(TokenStorageInterface $storage)
    {
        $this->storage = $storage;
    }
}
```

Определение сервиса для класа `TokenProvider` должно выглядеть таким образом:

```xml
<service id="token_provider" class="TokenProvider">
    <argument type="service" id="token_storage" />
</service>

<service id="token_storage" class="...">
</service>
```

Первый аргумент сервиса `token_provider` это ссылка на сервис `token_storage`. Класс хранилища токнов, таким образом, должен реализовывать интерфейс `TokenStorageInterface`, иначе он не будет корректным аргументом и вы получите фатальную ошибку.

##### Абстрактные определения для дополнительных аргументов

Предположим у вас есть другой провайдер токенов, `ExpiringTokenProvider`, который наследуется от `TokenProvider`, но имеет дополнительно свой аргумент конструктора - `$lifetime`:

```php
class ExpiringTokenProvider extends TokenProvider
{
    private $lifetime;

    public function __construct(TokenStorageInterface $storage, $lifetime)
    {
        $this->lifetime = $lifetime;

        parent::__construct($storage);
    }
}
```

Создавая определение сервиса для второго провайдера, вы можете просто скопировать аргумент из определения сервиса `token_provider`:

```xml
<service id="expiring_token_provider" class="ExpiringTokenProvider">
    <argument type="service" id="token_storage" />
    <argument>3600</argument><!-- lifetime -->
</service>
```

Однако, лучшим выходом из данной ситуации будет создание определения родительского сервиса, которое вы сможете использовать для определения дочерних сервисов, предоставляя им необходимые базовые аргументы:

```xml
<service id="abstract_token_provider" abstract="true">
    <argument type="service" id="token_storage" />
</service>

<service id="token_provider" class="TokenProvider" 
    parent="abstract_token_provider">
</service>

<service id="expiring_token_provider" class="ExpiringTokenProvider"
    parent="abstract_token_provider">
    <argument>3600</argument><!-- lifetime -->
</service>
```

Абстрактный сервис из примера выше имеет один аргумент и отмечен как абстрактный. Сервисы провайдеров используют `abstract_token_provider` в качестве родителя. Сервис `token_provider` не имеет дополнительных аргументов, таким образом он лишь наследует первый аргумент конструктора  от `abstract_token_provider`. Сервис `expiring_token_provider` также наследует первый аргумент `token_storage`, но также добавляет свой дополнительный аргумент `$lifetime`.

> #### Наследование свойств
> 
> Вне зависимости от того, является ли родительский сервис абстрактным или нет, дочерний сервис наследует нижеперечисленные свойства родительского сервиса:
> 
> - Класс
> - Аргументы конструктора (в порядке их появления)
> - Вызовы методов после создания экземпляра класса (@dbykadorov: судя по всему имеются в виду call вызовы при использовании [setter injection](http://symfony.com/doc/current/service_container.html#optional-dependencies-setter-injection))
> - Свойства, используемые для `property injection` (недостаки этого способа внедрения параметров описаны [тут](http://symfony.com/doc/current/service_container/injection_types.html#property-injection))
> - Фабричный класс или сервис, фабричный метод
> - Конфигуратор (штука весьма экзотичная, не рассматривается в данной книге)
> - Файл (необходимый для создания сервиса)
> - Признак, является ли создаваемый сервис публичным
>

#### Вызов обязательных set-методов (setters)

Иногда вы можете попасть в ситуациию, когда вы не захотите (или не сможете) переопределить конструктор сервиса и, следовательно, не сможете добавить дополнительные параметры в него, или же, возможно, некоторые зависимости еще не определены в момент создания класса сервиса. В таких случаях вы можете добавить в ваш класс set-метод, что позволит внедрить зависимость сразу после создания сервиса (или, фактически, в любой момент после создания):

```php
class SomeController
{
    private $container;

    public function setContainer(ContainerInterface $container)
    {
        $this->container = $container;
    }

    public function indexAction()
    {
        $service = $this->container->get('...');
    }
}
```

Так как контроллеру из примера выше для выполнения метода `indexAction()` необходим экземпляр `ContainerInterface`, вызов `setContainer` является обязательным. Поэтому в определении сервиса для него вы должны позаботиться о внедрении сервисного котейнера:

```xml
<service id="some_controller" class="SomeController">
    <call method="setContainer">
        <argument type="service" id="service_container" />
    </call>
</service>
```

Преимущества при использовании set-методов для внедрения зависимостей в том, что вам не нужно указывать все зависимости в виде аргументов конструктора. Иногда это означает, что вам не конструктор и вовсе не понадобится, или же вы можете оставить конструктор в неизменном виде. Недостатком данного метода является возможность ситуации, когда вы забудете вызвать set-метод, что приведёт к отсутствию необходимых зависимостей. В примере выше это привеёт к вызову метода `get()` от `null`, что, в свою очередь, вызовет фатальную ошибку PHP. По моему мненю, этот недостаток перекрывает все достоинства данного подхода, так как код получается "с душком", который называется `временнАя связность` (@dbykadorov: от слова "время", имеется в виду, что работоспособность вашего кода зависит от того был ли перед использованием сервиса вызван нужный set-метод или вы забыли добавить его описание сервиса) или `temporal coupling`. Таким образом этот тип внедрения делает ваш класс менее надёжным (@dbykadorov: о `temporal coupling` в PHP можно дополнительно почитать, например, [тут](https://habrahabr.ru/post/281330/)).

Для того, чтобы предотвратить серьёзные сбои (и чтобы помочь разработчику, который будет исправлять проблему, если она всё-таки возникнет) вы можете ограничить доступ к зависимому свойству через его геттер (метод `getXxx()`) и в нём проверять валидность соответствующего значения, например вот так:

```php
class SomeController
{
    public function indexAction()
    {
        $service = $this->getContainer()->get('...');
    }

    private function getContainer()
    {
        if (!($this->container instanceof ContainerInterface)) {
            throw new \RuntimeException('Service container is missing');
        }

        return $this->container;
    }
}
```

> #### ContainerAware
> 
> Компонент Symfony DependencyInjection содержит интерфейс `ContainerAwareInterface` и абстрактный класс `ContainerAware`, которые вы можете использовать для того, чтобы указать, что класс "осведомлён" ("aware" в оригинале) о сервисном контейнере. Использование этих классов предоставит вам set-метод по имени `setContainer()`, с помощью которого вы сможете передать сервисный контейнер в ваш класс. Контроллеры, которые реализуют интерфейс `ContainerAwareInterface`, автоматически получают доступ к контейнеру при помощи этого set-метода. Стандартный класс `Controller` из состава Symfony FrameworkBundle является "осведомлённым-о-контейнере" - `container-aware`. См. также главу 1, раздел 2.2 - `Определение контроллера для запуска`.

#### Вызов методов в абстрактных сервисах

Когда вы создаёте `container-aware` сервис, у вас будет много дублируещего кода в его определении. Разумным будет добавить вызов метода `setContainer()` в определение абстрактного сервиса:

```xml
<service id="abstract_container_aware" abstract="true">
    <call method="setContainer">
        <argument type="service" id="service_container" />
    </call>
</service>

<service id="some_controller" class="SomeController"
    parent="abstract_container_aware">
</service>
```

> #### Соглашение об именовании родительских сервисов
> 
> Определения родительских сервисов не обязательно должны быть абстрактными. Однако, когда вы опускаете атрибут `abstract="true"`, определение родительского сервиса будет трактоваться как определение обычного сервиса (и соответствующим образом валидироваться).
>
> Если же вы хотите создать определение абстрактного сервиса - пометьте его таковым, присвоив трибуту `abstract` значение `true` и добавьте префикс `abstract_` к его id (по аналогии с абстрактныи классами, имена которых традиционно начинаются с `Abstract`).
>
> Если же у вас есть определение родительского сервиса, который также должен сам быть самостоятельным сервисом, добавлять атрибут `abstract` не нужно, но, возможно, будет полезным добавить префикс `base_` к его id.

### 6.2 Необязательные (опциональные) зависимости

Иногда зависимости являются не обязатальными. Термин "не обязательные зависимости" может вам показаться противоречивым, так как если вы реально от чего-то не зависите, странно называть это "зависиомстями". Однако, встречаются ситуации, когда один сервис знает как использовать другой сервис, но в общем-то этот другой сервис не необходим для выполнения его функций. Например, сервис может знать как использовать сервис журналирования (логгер) для того, чтобы писать в лог какие-либо отладочные данные.

### Необязательные аргументы конструктора 

В случае, когда класс вашего сервиса знает как работать с логгером, он может иметь необязательный аргумент конструктора для него:

```php
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Psr\Log\LoggerInterface;

class AuthenticationListener
{
    private $eventDispatcher;
    private $logger;

    public function __construct(
        EventDispatcherInterface $eventDispatcher,
        LoggerInterface $logger = null
    ) {
        $this->eventDispatcher = $eventDispatcher;
        $this->logger = $logger;
    }
}
```

Для аргументов конструктора, которые должны быть либо экземплярами указанных классов, либо могут отсутствовать, вы можете использовать значение по умолчанию `null`. В этом случае, в определении вашего сервиса в можете выбрать стратегию поведения в случае их отсутствия:

```xml
<service id="authentication_listener" class="AuthenticationListener">
    <argument type="service" id="logger" on-invalid="ignore" />
</service>
```

Стратегия `ignore` на данный момент эквивалентна null-стратегии, в том смысле, что конструктор будет вызван со значением null, вместо запрошенного сервиса, если тот недоступен. Есть еще стратегия `exception`, которая применяется по умолчанию. При её использовании будет вызвано исключение, если внедряемый сервис не будет найден.

> #### Проверка необязательных зависимостей
>
> Если вы хотите проверить, внедрена или нет необязательная зависимость, вы должны написать примерно такой код:
> 
> ```php
> if ($this->logger instanceof LoggerInterface) {
>     ...
> }
> ```
> 
> Это более надёжный способ проверки, чем сравнение с NULL:
> 
> ```php
> if ($this->logger !== null) {
>     ...
> }
> ```
> 
> Думайте об этом в таком ключе: если что-то не является NULL, можем ли мы быть уверены, что это logger?

#### Не обязательные вызовы set-методов

Также, как и в случае с обязательными зависимостями, иногда бывает удобно/необходимо внедрить необязательные зависимости при помощи set-методов. Как правило, эта потребность возникает, если вы не хотите захлямлять сигнатуру конструктора:

```php
class AuthenticationListener
{
    private $eventDispatcher;
    private $logger;

    public function __construct(EventDispatcherInterface $eventDispatcher)
    {
        $this->eventDispatcher = $eventDispatcher;
    }

    public function setLogger(LoggerInterface $logger = null)
    {
        $this->logger = $logger;
    }
}
```

В определении сервиса вы можете добавить вызов метода `setLogger()` с сервисом журналирования в качестве аргумента. Вы также можете указать, что этот аргумент должен быть проигнорирован, в случае, если соответствующий сервис не будет найден (что делает эту зависимость по-настоящему необязательной):

```xml
<service id="authentication_listener" class="AuthenticationListener">
    <call method="setLogger">
        <argument type="service" id="logger" on-invalid="ignore" />
    </call>
</service>
```

Аргумент вызова метода `setLogger()` может иметь значение NULL, (когда сервис не определён), но метод будет вызван в любом случае, таким образом вы должны иметь в виду, что NULL является одним из валидных аргументов вызова метода `setLogger()`.

> #### Определение закрытых (non-public) зависимостей
> 
> Когда вы пишете код в тру-ООП стиле, у вас всегда всегда будет куча небольших сервисов, каждый из которых 
> выполняет только одну фиксированную функцию. Сервисы более высокого уровня будут внедрять их в качестве зависимостей. Сервисы более низких уровней как правило не должны пересекаться между собой; они лишь выполняют роль помошников для сервисов более высокого уровня. Чтобы не допустить возможности использования низкоуровневых сервисов в других частях приложения, например так:
> 
> ```php
> $container->get('low_level_service_id');
> ```
> 
> вы должны пометить их как закрытые (non-public), для этого в опредении низкоуровневого сервиса нужно присвоить атрибуту public значение "false":
> 
> ```xml
> <service id="low_level_service_id" class="..." public="false">
> </service>
> ```

### 6.3 Коллекции сервисов

В большинстве случаев вы будете внедрять зависимости через конструктор или аргументы set-методов. Но иногда возникает необходимость внедрить в качестве зависиомсти целую коллекцию сервисов, например, если вы хотите предоставить несколько альтернатив (стратегий) для достижения некоторых целей:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct(array $renderers)
    {
        $this->renderers = $renderers;
    }

    public function render($object)
    {
        foreach ($this->renderers as $renderer) {
            if ($renderer->supports($object) {
                return $renderer->render($object);
            }
        }
    }
}
```

Определение такого сервиса может выглядеть следующим образом:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument type="collection">
        <argument type="service" id="domain_object_renderer" />
        <argument type="service" id="user_renderer" />
    </argument>
</service>
```

Аргумент типа `collection` будет преобразован в массив, содержащий сервисы, id которых перечислены в этой коллекции:

```php
array(
    0 => ...
    1 => ...
)
```

Вы также можете для каждого элемента коллекции указать ключ при помощи атрибута `key`:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument type="collection">
        <argument
            key="domain_object" type="service"
            id="domain_object_renderer" />
        <argument
            key="user" type="service"
            id="user_renderer" />
    </argument>
</service>
```

Значение атрибута `key` будет использовано в качестве ключа для соответствующих значений коллекции:

```php
array(
    'domain_object' => ...
    'user' => ...
)
```

#### Вызов нескольких методов

Если вы включите "строгий" режим и перечитаете код класса `ObjectRenderer`, вы вероятно заметите, что нельзя доверять массиву `$renderers` в том, что он содержит только валидные рендереры (которые, к примеру, должны реализовывать интерфейс `RendererInterface`). Следовательно, вы вероятно захотите выделить отдельный метод для добавления рендерера:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct()
    {
        $this->renderers = array();
    }

    public function addRenderer($name, RendererInterface $renderer)
    {
        $this->renderers[$name] = $renderer;
    }
}
```

Конечно же, если имя рендерера не имеет значения, можно убрать параметр `$name`. Важно тут другое: когда кто-либо вызовет метод `addRenderer` и передаст ему в качестве аргумента объект, который не является реализацией интерфейса `RendererInterface`, этот вызов не будет успешным, так как не будет соблюдено ограничение по типу аргумента.
Определение сервиса также необходимо изменить, чтобы для каждого рендерера вызывался бы метод `addRenderer()`:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <call method="addRenderer">
        <argument>domain_object</argument>
        <argument type="service" id="domain_object_renderer" />
    </call>
    <call method="addRenderer">
        <argument>user</argument>
        <argument type="service" id="user_renderer" />
    </call>
</service>
```

#### Лучшее из двух миров

Возможно вас также заинтересует идея о том, как объединить походы для работы с коллекциями сервисов, описанные выше, что позволило бы разработчикам передавать как набор рендереров по-умолчанию через аргумент конструктора и/или добавлять рендереры один за другим, используя метод `addRenderer()`:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct(array $renderers)
    {
        foreach ($renderers as $name => $renderer) {
            $this->addRenderer($name, $renderer);
        }
    }

    public function addRenderer($name, RendererInterface $renderer)
    {
        $this->renderers[$name] = $renderer;
    }
}
```

#### Метки сервисов (tags)

We already have a nice setup for manually adding renderers, but what if other parts of your
application (like other bundles) should be able to register specific renderers? The best way to do
this is by using service tags:

```xml
<!-- in some other bundle -->
<service id="date_time_renderer" class="DateTimeRenderer">
    <tag name="specific_renderer" alias="date_time" />
</service>
```

Each tag has a name, which you can choose yourself. Each tag can also have any number of extra
attributes (like alias above). These attributes allow you to further specify any requested behavior.
To collect services with these tags, you have to create a compiler pass like this one:

```php
namespace Matthias\RendererBundle\DependencyInjection\Compiler;

use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        // collect all tagged services in the entire project
        $taggedServiceIds
            = $container ->findTaggedServiceIds('specific_renderer');

        $objectRendererDefinition
            = $container->getDefinition('object_renderer');

        foreach ($taggedServiceIds as $serviceId => $tags) {
    
            // services can have many tag elements with the same tag name
            foreach ($tags as $tagAttributes) {
    
                // call addRenderer() to register this specific renderer
                $objectRendererDefinition
                    ->addMethodCall('addRenderer', array(
                        $tagAttributes['alias'],
                        new Reference($serviceId),
                    ));
            }
        }
    }
}
```

Register this compiler pass in your bundle class:

```php
use Matthias\RendererBundle\DependencyInjection\Compiler\RenderersPass;
use Symfony\Component\DependencyInjection\ContainerBuilder;

class RendererBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        $container->addCompilerPass(new RenderersPass());
    }
}
```

Inside the process() method of the compiler pass, first all tags with the name specific_-
renderer are collected. This will result in an array of which the keys are service ids and the values
are arrays of attribute arrays. This is because each service definition can have multiple tags with the
same name (but maybe with different attributes).

Then, the service definition for the ObjectRenderer class is retrieved and while iterating over the
tags, a Reference is created which refers to each renderer service that is tagged as “specific_renderer”
and together with the provided value for alias, these are used as arguments to a call to the method
addRenderer().

All of this means that when the object_renderer service is requested, first of all an instance of
ObjectRenderer gets created. But afterwards, some calls are made to its addRenderer() method to
add the specific renderers tagged as specific_renderer.

#### Single method call

There are many possible approaches when collecting services in a compiler pass. For instance, you
can collect service references in an array and set them all at once, by adding a method call to
setRenderers():

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        $renderers = array();

        foreach ($taggedServiceIds as $serviceId => $tags) {
            foreach ($tags as $tagAttributes) {
                $name = $tagAttributes['alias'];
                $renderer = new Reference($serviceId);
                $renderers[$name] = $renderer;
            }
        }

        $objectRendererDefinition
            ->addMethodCall('setRenderers', array($renderers));
    }
}
```

#### Replacing a single argument

When it’s possible - like in one of the examples above - to inject a collection of renderers as a
constructor argument, there is another way you can do this: set a constructor argument directly:

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        $renderers = array();

        // collect service references
        ...

        $objectRendererDefinition->replaceArgument(0, $renderers);
    }
}
```

Replacing arguments can only be done when you have defined them in the first place (for
instance as an empty argument):

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument /><!-- specific renderers -->
</service>
```

#### Service ids instead of references

Whenever you request the object_renderer service, all the specific renderers are instantiated too.
Depending on the cost of instantiating these renderers it could be a good idea to add support for
lazy-loading. This can be accomplished by making the ObjectRenderer container-aware and by
injecting service ids, not the services themselves:

```php
class LazyLoadingObjectRenderer
{
    private $container;
    private $renderers;

    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    public function addRenderer($name, $renderer)
    {
        $this->renderers[$name] = $renderer;
    }

    public function render($object)
    {
        foreach ($this->renderers as $name => $renderer) {
            if (is_string($renderer)) {
                // $renderer is assumed to be a service id
                $renderer = $this->container->get($renderer);
            }

            // check if the renderer is an instance of RendererInterface
            ...
        }
    }
}
```

The compiler pass should be modified to not pass references to services, but just service ids:

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        foreach ($taggedServiceIds as $serviceId => $tags) {
            foreach ($tags as $tagAttributes) {
                $objectRendererDefinition
                    ->addMethodCall('addRenderer', array(
                        $tagAttributes['alias'],
                        $serviceId,
                    )
                );
            }
        }
    }
}
```

Also don’t forget to provide the service container as a constructor argument:

```xml
<service id="object_renderer" class="LazyLoadingObjectRenderer">
    <argument type="service" id="service_container" />
</service>
```

Of course, any of the strategies mentioned above can be used with this lazy-loading class (single
method call, multiple method calls or argument replacement).
Before you consider changing your class to make use of the service container directly, please
read the chapter Reduce coupling to the framework, specifically The performance issue.

### 6.4 Delegated creation

Instead of fully defining services upfront by a service definition with a class, arguments and method
calls, you can also leave the details to be figured out at runtime, by delegating the creation of services
to a factory method. Factory methods can be either static methods or object methods. In the first
case, you can provide the class name and the method name as attributes of the service definition:

```xml
<service id="some_service" class="ClassOfResultingObject"
    factory-class="Some\Factory" factory-method="create">
    <argument>...</argument>
</service>
```

When some_service is being requested for the first time, the service will be retrieved by calling
Some\Factory::create() statically with any arguments provided. The result will be stored in
memory, so the factory method is called only once.
Most factory methods nowadays are not static anymore, which means that the factory method
should be called on an instance of the factory itself. This instance should be defined as a service:

```
<!-- a service created by some_factory_service -->
<service id="some_service" class="ClassOfResultingObject"
    factory-service="some_factory_service" factory-method="create">
    <argument>...</argument>
</service>

<!-- the factory -->
<service id="some_factory_service" class="Some\Factory">
</service>
```

#### Not so useful

Though the options for delegating the creation of services to other services seem really great, I
have not used them very often. They are almost exclusively useful when you are creating service
definitions for older PHP classes since in the (not so distant) past, creation logic was often hidden
inside static factory classes (remember Doctrine_Core::getTable()?).

My objection to factory classes with static factory methods is that static code is global code
and that executing that code may have side effects that can not be isolated (for instance in a test
scenario). Besides, any dependency of such a static factory method has to be by definition static
itself, which is also really bad for isolation and prevents you from replacing (part of) the creation
logic by your own code.

Factory objects (or factory services) are slightly better. However, the need for them very likely
points to some kind of design problem. A service should not need a factory, since it will be created
only once in a predetermined (and deterministic) way and from then on be perfectly reusable by
any other object. The only things that are dynamic about a service, should be the arguments of the
methods that are part of its public interface (see also State and context).

#### Sometimes useful

One particularly nice example of using a factory service and method for retrieving a service is the
case of a Doctrine repository. When you need one, you would normally inject an entity manager as
a constructor argument and later retrieve a specific repository:

```php
use Doctrine\ORM\EntityManager;

class SomeClass
{
    public function __construct(EntityManager $entityManager)
    {
        $this->entityManager = $entityManager;
    }

    public function doSomething()
    {
        $repository = $this->entityManager->getRepository('User');

        ...
    }
}
```

But using a factory service and method you could directly inject the correct repository itself:

```php
class SomeClass
{
    public function __construct(UserRepository $userRepository)
    {
        $this->userRepository = $userRepository;
    }
}
```

This is the corresponding service definition:

```xml
<service id="some_service" class="SomeClass">
    <argument type="user_repository" />
</service>

<service id="user_repository" class="UserRepository"
    factory-service="entity_manager" factory-method="getRepository">
    <argument>User</argument>
</service>
```

By looking at the constructor arguments of SomeClass it is immediately clear that it needs a
User repository, which is much more specific and communicative than the earlier example in which
SomeClass needed an EntityManager. Besides making the class itself much cleaner, it will also make
it much easier to create a stand-in object for the repository when you are writing a unit test for this
class. Instead of creating a mock for both the entity manager and the repository, you only have to
create one for the repository itself.

### 6.5 Manually creating services

Usually you create services by loading service definitions from a file:

```php
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

class SomeBundleExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $locator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new XmlFileLoader($container, $locator);
        $loader->load('services.xml');
    }
}
```

But some services can not be defined in a configuration file. They should be defined dynamically,
because their name, class, arguments, tags, etc. are not fixed.

#### Definition

Manually creating a service definition means creating an instance of Definition, and optionally
providing a class name. The definition will get its identifier when it is set on the ContainerBuilder
instance:

```php
use Symfony\Component\DependencyInjection\Definition;

$class = ...; // set a class name for the definition

$definition = new Definition($class);

$container->setDefinition('the_service_id', $definition);
```

The equivalent of this in XML would be:

```xml
<service id="the_service_id" class="...">
</service>
```

You can make the definition non-public if it only exists as a dependency of other services:

```php
$definition->setPublic(false);
```

#### Arguments

When the service requires some constructor arguments, you may set them all at once:

```php
use Symfony\Component\DependencyInjection\Reference;

$definition->setArguments(array(
    new Reference('logger') // reference to another service
    true // boolean argument,
    array(
        'table_name' => 'users'
    ) // array argument
    ...
));
```

Arguments should be either references to other services, array values or scalar values (or a mix
of these). This is because all service definitions will eventually be stored as a simple PHP file. A
reference to another service can be created by using a Reference object with the id of the service
that should be injected.

You can also add the arguments one by one, in the right order:

```php
$definition->addArgument(new Reference('logger'));
$definition->addArgument(true);
...
```

Finally, when you are modifying an existing service definition with a list of arguments, you
could replace them by providing their numeric index:

```php
$definition->setArguments(array(null, null));

...

$definition->replaceArgument(0, new Reference('logger'));
$definition->replaceArgument(1, true);
```

The equivalent in XML would be:

```xml
<service id="..." class="...">
    <argument type="service" id="logger" />
    <argument>true</argument>
</service>
```

#### Tags

There is another thing you may want to do when working with Definition objects: adding tags to
them. A tag consists of the name of the tag and an array of attributes. A definition can have multiple
tags with the same tag name:

```php
$definition->addTag('kernel.event_listener', array(
    'event' => 'kernel.request'
);
$definition->addTag('kernel.event_listener', array(
    'event' => 'kernel.response'
);
```

In XML you would write this like:

```xml
<service id="..." class="...">
    <tag name="kernel.event_listener" event="kernel.request">
    <tag name="kernel.event_listener" event="kernel.response">
</service>
```

#### Aliases

Before talking about what you can do with all this knowledge, there is one last thing you’ll need:
creating aliases for services:

```php
$container->setAlias('some_alias', 'some_service_id');
```

Now whenever you request the service some_alias, you will in fact get the service some_-
service_id.

### 6.6 The Configuration class

Before we continue, I need to explain a few things about the Configuration class. You may have
noticed it earlier, and maybe you have even created one yourself.

Most of the times you will use a Configuration class to define all the possible configuration
options for your bundle (though the Config Component is highly decoupled so you can also use
anything described below in an entirely different context). The name of the class or its namespace
is actually irrelevant, as long as it implements ConfigurationInterface:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('name_of_bundle');

        $rootNode
            ->children()
            // define configuration nodes
            ...
            ->end()
        ;

        return $treeBuilder;
    }
}
```

There is one public method: getConfigTreeBuilder(). This method should return a TreeBuilder
instance which is a builder you use to describe all configuration options, including their validation
rules. Creating a config tree starts with defining a root node:

```php
1 $rootNode = $treeBuilder->root('name_of_bundle');
```

The name of the root node should be the name of the bundle, without “bundle”, but lower-cased
and with underscores. So the node name for MatthiasAccountBundle will be matthias_account.
The root node is an array node. It can have any child node you like:

```php
$rootNode
    ->children()
        ->booleanNode('auto_connect')
            ->defaultTrue()
        ->end()
        ->scalarNode('default_connection')
            ->defaultValue('default')
        ->end()
    ->end()
;
```

> #### Learn to write great config trees
>
> When you want to become a proficient bundle creator, practice a lot with defining these
> config nodes. Your bundle configurations will be much better and very flexible. Read more
> about the configuration nodes in the [documentation of the Config Component](http://symfony.com/doc/current/components/config/definition.html). Also take
> a look at Configuration class from existing bundles and try to follow their example.

Usually, you will use an instance of the Configuration class inside a bundle’s extension class,
to process a given set of configuration arrays. These configuration arrays have been collected
by the kernel, by loading all the relevant configuration files (like config_dev.yml, config.yml,
parameters.yml, etc.).

```php
class MatthiasAccountExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );
    }
}
```

The processConfiguration() method of the Extension class instantiates a Processor and
finalizes the config tree retrieved from the Configuration object. It then asks the processor to process (validate and merge) the raw configuration arrays:

```php
final protected function processConfiguration(
    ConfigurationInterface $configuration,
    array $configs
) {
    $processor = new Processor();

    return $processor->processConfiguration($configuration, $configs);
}
```

When there were no validation errors, you can then use the configuration values in any way you
like. You can define or modify container parameters or service definitions based on the configuration
values. In the following chapters we will discuss many different ways to do this.

### 6.7 Dynamically add tags

Say you want to create a generic event listener, which listens to a configurable list of events, like
kernel.request, kernel.response, etc. This is what your Configuration class might look like:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('generic_listener');

        $rootNode
            ->children()
                ->arrayNode('events')
                    ->prototype('scalar')
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

It allows a list of event names to be configured like this:


```yaml
generic_listener:
    events: [kernel.request, kernel.response, ...]
```
The standard way to register an event listener would be to add tags to the event listener’s service
definition in services.xml:

```xml
<service id="generic_event_listener" class="...">
    <tag name="kernel.event_listener" event="..." method="onEvent" />
    <tag name="kernel.event_listener" event="..." method="onEvent" />
</service>
```

But in this situation, we don’t know in advance to which events the listener should listen, so
these events can not be defined in a configuration file. Luckily - as we saw earlier - we can add tags
to service definitions on the fly. This can be done inside the container extension:

```php
class GenericListenerExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );
    
        // load services.xml
        $loader = ...;
        $loader->load('services.xml');
    
        $eventListener = $container
            ->getDefinition('generic_event_listener');
    
        foreach ($processedConfig['events'] as $eventName) {
            // add a kernel.event_listener tag for each event
            $eventListener
                ->addTag('kernel.event_listener', array(
                    'event' => $eventName,
                    'method' => 'onEvent'
                ));
        }
    }
}
```

There is one extra step you might take to prevent a dangling listener service when there are no
events to which it should listen:

```php
if (empty($processedConfig['events'])) {
    $container->removeDefinition('generic_event_listener');
}
```

### 6.8 Strategy pattern for loading exclusive services

Often bundles provide multiple ways of doing a single thing. For instance, a bundle that provides
some kind of mailbox functionality may have different storage implementations, like one storage
manager for Doctrine ORM and one for MongoDB. To make the choice for a specific storage manager
configurable, create a Configuration class like this:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('browser');

        $rootNode
            ->children()
                ->scalarNode('storage_manager')
                    ->validate()
                        ->ifNotInArray(array('doctrine_orm', 'mongo_db')
                        ->thenInvalid('Invalid storage manager')
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Then given there are two service definition files for each of the storage managers, like
doctrine_orm.xml:

```xml
<services>
    <service id="mailbox.doctrine_orm.storage_manager" class="...">
    </service>
</services>
```

And mongo_db.xml:

```xml
<services>
    <service id="mailbox.mongo_db.storage_manager" class="...">
    </service>
</services>
```

You could then load either of these files by doing something like this in your container extension:

```php
class MailboxExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        // create an XmlLoader
        $loader = ...;

        // load only the services for the given storage manager
        $storageManager = $processedConfig['storage_manager'];
        $loader->load($storageManager.'.xml');

        // make the specific storage manager available as the general one
        $container->setAlias(
            'mailbox.storage_manager',
            'mailbox.'.$storageManager.'.storage_manager'
        );
    }
}
```

A convenient alias is created in the end to allow other parts of the application to just request
the mailbox.storage_manager service, instead of worrying about the storage-specific service that
should be used. However, the way this is done is too rigid: the id of each specific storage manager
service should conform to the pattern mailbox.{storageManagerName}.storage_manager. It would
be better to define the alias inside the service definition files themselves:

```xml
<services>
    <service id="mailbox.doctrine_orm.storage_manager" class="...">
    </service>

    <service id="storage_manager"
        alias="mailbox.doctrine_orm.storage_manager">
    </service>
</services>
```

Using the strategy pattern for loading service definitions has many advantages:

- Only the services that are useful in the current application will be loaded. When you don’t
have a MongoDB server up and running, there will be no services that accidentally refer to it.
- The setup is open for extension, since you can add the name of another storage manager to
the list in the Configuration class and then add a service definition file with the necessary
services and an alias.

### 6.9 Loading and configuring additional services

Say you have a bundle dedicated to input filtering. Probably you offer several different services, like
services for filtering form data, and services for filtering data stored using Doctrine ORM. It should
be possible to enable or disable any of these services or collections of services at any time because
they may not all be applicable to your specific situation. There is a handy shortcut for configuration
definitions to accomplish a thing like this:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('input_filter');

        $rootNode
            ->children()
                ->arrayNode('form_integration')
                    // will be enabled by default
                    ->canBeDisabled()
                ->end()
                ->arrayNode('doctrine_orm_integration')
                    // will be disabled by default
                    ->canBeEnabled()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

With a configuration tree like this, you can enable or disable specific parts of the bundle in
config.yml:

```yaml
input_filter:
    form_integration:
        enabled: false
    doctrine_orm_integration:
        enabled: true
```

Inside your container extension you can then load the appropriate services:

```php
class InputFilterExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        if ($processedConfig['doctrine_orm_integration']['enabled']) {
            $this->loadDoctrineORMIntegration(
                $container,
                $processedConfig['doctrine_orm_integration']
            );
        }

        if ($processedConfig['form_integration']['enabled']) {
            $this->loadFormIntegration(
                $container,
                $processedConfig['form_integration']
            );
        }

        ...
    }

    private function loadDoctrineORMIntegration(
        ContainerBuilder $container,
        array $configuration
    ) {
        // load services, etc.
        ...
    }

    private function loadFormIntegration(
        ContainerBuilder $container,
        array $configuration
    ) {
        ...
    }
}
```

Each of the stand-alone parts of the bundle can be loaded separately like this.

#### A cleaner configuration class

One or two of these stand-alone bundle parts can be easily handled, but soon the Configuration
class will contain many lines of code in just one method. You can clean this up a bit by using the
append() method in combination with some private methods:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();

        $rootNode = $treeBuilder->root('input_filter');

        $rootNode
            ->append($this->createFormIntegrationNode())
            ->append($this->createDoctrineORMIntegrationNode())
        ;

        return $treeBuilder;
    }

    private function createDoctrineORMIntegrationNode()
    {
        $builder = new TreeBuilder();

        $node = $builder->root('doctrine_orm_integration');

        $node
            ->canBeEnabled()
            ->children()
                // maybe add some more configuration
                ...
            ->end();

        return $node;
    }

    private function createFormIntegrationNode()
    {
        ...
    }
}
```

### 6.10 Configure which services to use

Instead of using the Strategy pattern for loading services you may also allow developers to manually
configure a service they want to use. For example, if your bundle needs some kind of encrypter
service and the bundle does not provide one itself, you would want to ask the developer to provide
the encrypter by its service id:

```yaml
matthias_security:
    encrypter_service: my_encrypter_service_id
```

Your Configuration class should then look like this:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('matthias_security');

        $rootNode
            ->children()
                ->scalarNode('encrypter_service')
                    ->isRequired()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Inside the bundle’s extension class, you could then create an alias for the configured service.

```php
class MatthiasSecurityExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        $container->setAlias(
            'matthias_security.encrypter',
            $processedConfig['encrypter_service']
        );
    }
}
```

So even though the service id of the encrypter may originally be anything, now you have a stable
reference to it - an alias - which you can use inside any of your bundle’s service definitions:

```xml
<service id="matthias_security.encrypted_data_manager" class="...">
    <argument type="service" id="matthias_security.encrypter" />
</service>
```

Of course the assumption here is that the manually configured encrypter service is a valid
encrypter object. You can not be sure at configuration time that this is true, so you will have to
verify this at runtime. The usual way to do this would be to add the appropriate type-hint to classes
of services that use the encrypter service:

```php
class EncryptedDataManager
{
    public function __construct(EncrypterInterface $encrypter)
    {
        // $encrypter is a valid encrypter
    }
}
```

### 6.11 Completely dynamic service definitions

There are situations when you know almost nothing about the services you need, until you have
processed the configuration. Say you want the users of your bundle to define a set of resources as
services. These resources can be of type directory or file. You want to create these services on the
fly since they differ per application and you need to collect them using a custom service tag, called
resource. Your Configuration class may look like this:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('resource_management');

        $rootNode
            ->children()
                ->arrayNode('resources')
                    ->prototype('array')
                        ->children()
                            ->scalarNode('type')
                                ->validate()
                                    ->ifNotInArray(
                                        array('directory', 'file')
                                    )
                                    ->thenInvalid('Invalid type')
                                ->end()
                            ->end()
                            ->scalarNode('path')
                            ->end()
                        ->end()
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

An example resource configuration:

```yaml
resource_management:
    resources:
        global_templates:
            type: directory
            path: Resources/views
        app_kernel:
            type: file
            path: AppKernel.php
```

When the resources are defined like this, you can create service definitions for them in the
container extension:

```php
class ResourceManagementExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        $resources = $processedConfig['resources'];

        foreach ($resources as $name => $resource) {
            $this->addResourceDefinition($container, $name, $resource);
        }
    }

    private function addResourceDefinition(
        ContainerBuilder $container,
        $name,
        array $resource
    ) {
        // determine the class
        $class = $this->getResourceClass($resource['type']);

        $definition = new Definition($class);

        // add a specific tag
        $definition->addTag('resource');

        $serviceId = 'resource.'.$name;

        $container->setDefinition($serviceId, $definition);
    }

    private function getResourceClass($type)
    {
        if ($type === 'directory') {
            return 'Resource\Directory';
        } elseif ($type === 'file') {
            return 'Resource\File';
        }

        throw new \InvalidArgumentException('Type not supported');
    }
}
```

When these manually created service definitions need arguments, method calls, etc. use the
techniques described above to add these dynamically too.
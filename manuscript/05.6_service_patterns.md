## Шаблоны создания сервисов

A service is an object, registered at the service container under a certain id. A service definition is a
bit of configuration to define such a service, so that it can be instantiated at any time by the service
container.
6.1 Required dependencies
Most objects need some other objects and maybe a scalar value (like an API key) or an array of
values (either scalar values or objects) to be able to do their work. These are called its dependencies.
We will first discuss how you can define required dependencies for services.
Required constructor arguments
The usual way to make sure a service gets its dependencies is by injecting them as constructor
arguments:
1 class TokenProvider
2 {
3 private $storage;
4 5
public function __construct(TokenStorageInterface $storage)
6 {
7 $this->storage = $storage;
8 }
9 }
The service definition for the TokenProvider class would look like this:
1 <service id="token_provider" class="TokenProvider">
2 <argument type="service" id="token_storage" />
3 </service>
4 5
<service id="token_storage" class="...">
6 </service>
The first argument of the token_provider service is a reference to the token_storage service.
The class used for the storage should therefore implement TokenStorageInterface, or else it is not
a correct argument and you get a Fatal error.
Abstract definitions for extra arguments
Say you have another token provider, an ExpiringTokenProvider, which extends from TokenProvider,
but has an extra constructor argument, $lifetime:Service patterns 30
1 class ExpiringTokenProvider extends TokenProvider
2 {
3 private $lifetime;
4 5
public function __construct(TokenStorageInterface $storage, $lifetime)
6 {
7 $this->lifetime = $lifetime;
8 9
parent::__construct($storage);
10 }
11 }
When creating a service definition for this second token provider, you could just copy the
argument from the existing token_provider definition:
1 <service id="expiring_token_provider" class="ExpiringTokenProvider">
2 <argument type="service" id="token_storage" />
3 <argument>3600</argument><!-- lifetime -->
4 </service>
In these situations it’s better to create a parent service definition, which you can use to define
everything that its child definitions should have in common:
1 <service id="abstract_token_provider" abstract="true">
2 <argument type="service" id="token_storage" />
3 </service>
4 5
<service id="token_provider" class="TokenProvider"
6 parent="abstract_token_provider">
7 </service>
8 9
<service id="expiring_token_provider" class="ExpiringTokenProvider"
10 parent="abstract_token_provider">
11 <argument>3600</argument><!-- lifetime -->
12 </service>
The abstract service has one argument and is marked as abstract. The token provider services
mention abstract_token_provider as their parent. The token_provider service has no extra
arguments, so it just inherits the first constructor argument from abstract_token_provider. The
expiring_token_provider service also inherits the token_storage service as the first argument, but
adds an extra argument for $lifetime.Service patterns 31
Inherited properties
Whether or not the parent of a service is abstract, these are the properties a child service
definition inherits from its parent definition:
• Class
• Constructor arguments (in order of appearance)
• Method calls made to it after creation
• Property injections*
• Factory class or factory service, and factory method
• Configurator (a bit exotic, not discussed here)
• File (required for creating this service)
• Whether or not the service is public
* All the disadvantages of property injection are listed here¹
Required setter calls
In some cases you don’t want to override the constructor and add extra required arguments, or some
of the dependencies are not yet determined at the time the service gets created. For these situations,
you may add setter methods to your class, to allow someone to inject a dependency immediately
after the service was created (or in fact, at any moment afterwards):
1 class SomeController
2 {
3 private $container;
4 5
public function setContainer(ContainerInterface $container)
6 {
7 $this->container = $container;
8 }
9
10 public function indexAction()
11 {
12 $service = $this->container->get('...');
13 }
14 }
Since (as you can see in the example above) an instance of ContainerInterface really is required
to run the indexAction() method, this is a required setter call. So in your service definition you
should take care that the service container gets injected:
¹http://symfony.com/doc/current/components/dependency_injection/types.html#property-injectionService patterns 32
1 <service id="some_controller" class="SomeController">
2 <call method="setContainer">
3 <argument type="service" id="service_container" />
4 </call>
5 </service>
The advantage of using setters for dependency injection is that you are not required to have a
constructor argument for the dependency anymore. Sometimes this means that you don’t need to
have a constructor at all, or that you can leave an existing constructor as it is. The disadvantage is
that you may forget to call the setter, so that one of the dependencies of an object is missing. In the
example above, a call will then be made to the get() method of a non-object (null) which results in
PHP throwing a Fatal error. In my opinion, this one disadvantage, is usually much bigger than any
advantage you can think of, since it introduces a code smell called “temporal coupling”. It thereby
makes your class somewhat unreliable.
To prevent these severe crashes from happening (and to help a developer who encounters the
error to fix the problem) you may choose to wrap calls to dependencies that should have been
injected using a setter:
1 class SomeController
2 {
3 public function indexAction()
4 {
5 $service = $this->getContainer()->get('...');
6 }
7 8
private function getContainer()
9 {
10 if (!($this->container instanceof ContainerInterface)) {
11 throw new \RuntimeException('Service container is missing');
12 }
13
14 return $this->container;
15 }
16 }
ContainerAware
The Symfony DependencyInjection Component contains a ContainerAwareInterface
and an abstract ContainerAware class which you can use to indicate that a class is
“aware” of the service container. This will give you a setter called setContainer(), by
which you can provide the service container from the outside. Controllers that implement ContainerAwareInterface, automatically receive the container via this setter. The
standard Controller from the Symfony FrameworkBundle is container-aware. See also
Resolving the controllerService patterns 33
Method calls in abstract definitions
When you create container-aware services, you will have much code duplication in your service
definitions. It may then be a good idea to add the call to setContainer() to an abstract service
definition:
1 <service id="abstract_container_aware" abstract="true">
2 <call method="setContainer">
3 <argument type="service" id="service_container" />
4 </call>
5 </service>
6 7
<service id="some_controller" class="SomeController"
8 parent="abstract_container_aware">
9 </service>
Naming parent service definitions
Parent service definitions don’t need to be abstract definitions. However, when you leave
out the abstract="true" attribute, the parent definition will be treated like a normal
service definition (and also validated like one).
When you have an abstract service definition, mark it as abstract by setting the abstract
attribute to true and by adding abstract_ in front of its service id (just like abstract classes
by convention start with Abstract).
When you have a parent service definition, which should also be treated as a service by
itself, don’t add an abstract attribute and maybe add base_ in front of its service id.
6.2 Optional dependencies
Sometimes dependencies are optional. When you think about the term “optional dependencies” this
feels a bit like a contradiction, because if you don’t really depend on them, they are not dependencies.
However, there are situations where a service knows how to use another service, but does not
actually need it for doing its job. For instance, a service may know how to deal with a logger to
log some things for debugging purposes.
Optional constructor arguments
In case your service’s class knows how to work with a logger, it may have an optional constructor
argument for it:Service patterns 34
1 use Symfony\Component\EventDispatcher\EventDispatcherInterface;
2 use Psr\Log\LoggerInterface;
3 4
class AuthenticationListener
5 {
6 private $eventDispatcher;
7 private $logger;
8 9
public function __construct(
10 EventDispatcherInterface $eventDispatcher,
11 LoggerInterface $logger = null
12 ) {
13 $this->eventDispatcher = $eventDispatcher;
14 $this->logger = $logger;
15 }
16 }
For constructor arguments that should be either an object of the given class/interface, or nothing,
you can use the default value null. Then in your service definition, choose a strategy for dealing
with a missing service:
1 <service id="authentication_listener" class="AuthenticationListener">
2 <argument type="service" id="logger" on-invalid="ignore" />
3 </service>
The ignore strategy is currently equivalent to the null strategy, in that it will call the constructor
with a null value instead of the requested service. There is also the exception strategy, which is
the default strategy. This will raise an exception when the injected service could not be found.Service patterns 35
Checking for optionally injected dependencies
When you want to check whether or not an optional dependency was injected, you should
do it like this:
1 if ($this->logger instanceof LoggerInterface) {
2 ...
3 }
This is much more reliable than using:
1 if ($this->logger !== null) {
2 ...
3 }
Think about it: if something is not the same as null, can it then be inferred that it is a
logger?
Optional setter calls
Just like with required dependencies, there is sometimes a good case for injecting optional dependencies using a setter. Especially when you don’t want to muddle with the constructor signature:
1 class AuthenticationListener
2 {
3 private $eventDispatcher;
4 private $logger;
5 6
public function __construct(EventDispatcherInterface $eventDispatcher)
7 {
8 $this->eventDispatcher = $eventDispatcher;
9 }
10
11 public function setLogger(LoggerInterface $logger = null)
12 {
13 $this->logger = $logger;
14 }
15 }
In the service definition you can add a call to setLogger() with the logger service as an
argument. When this service does not exist, you can indicate that it should be ignored (so that
this dependency is truly optional):Service patterns 36
1 <service id="authentication_listener" class="AuthenticationListener">
2 <call method="setLogger">
3 <argument type="service" id="logger" on-invalid="ignore" />
4 </call>
5 </service>
The argument of the call to setLogger() can be null (when the service is not defined), but
the method will be called anyway, so you have to take good care that null is in fact an acceptable
argument of the setLogger() method.
Mark dependencies as non-public
When you program in a nice object-oriented style, you always end up with lots of small
services, each with just one responsibility. Higher-level services will have them injected as
dependencies. The lower-level services are not meant to be used on their own; they only
make sense as collaborators of high-level services. In order to prevent other parts of the
system to retrieve low-level services from the service container directly:
1 $container->get('low_level_service_id');
You should mark these services as non-public:
1 <service id="low_level_service_id" class="..." public="false">
2 </service>
6.3 A collection of services
In most situations you inject specific services as constructor or setter arguments. But sometimes you
need to inject a collection of services, that are treated in the same way, for instance when you want
to provide several alternative ways (strategies) to achieve something:
1 class ObjectRenderer
2 {
3 private $renderers;
4 5
public function __construct(array $renderers)
6 {
7 $this->renderers = $renderers;
8 }
9
10 public function render($object)Service patterns 37
11 {
12 foreach ($this->renderers as $renderer) {
13 if ($renderer->supports($object) {
14 return $renderer->render($object);
15 }
16 }
17 }
18 }
In a service definition this may look like:
1 <service id="object_renderer" class="ObjectRenderer">
2 <argument type="collection">
3 <argument type="service" id="domain_object_renderer" />
4 <argument type="service" id="user_renderer" />
5 </argument>
6 </service>
This collection type argument will be converted to an array, containing the services referenced
by their ids:
1 array(
2 0 => ...
3 1 => ...
4 )
Optionally you could also give each argument inside the collection a key attribute.
1 <service id="object_renderer" class="ObjectRenderer">
2 <argument type="collection">
3 <argument
4 key="domain_object" type="service"
5 id="domain_object_renderer" />
6 <argument
7 key="user" type="service"
8 id="user_renderer" />
9 </argument>
10 </service>
The value of the key attribute will be used as the key for each value of the collection:Service patterns 38
1 array(
2 'domain_object' => ...
3 'user' => ...
4 )
Multiple method calls
When you read the code of the ObjectRenderer class again in “strict” mode, it appears you
cannot trust the $renderers array to contain only valid renderers (which, let’s say, implement
RendererInterface). Therefore, you may decide to dedicate a special method for adding a renderer:
1 class ObjectRenderer
2 {
3 private $renderers;
4 5
public function __construct()
6 {
7 $this->renderers = array();
8 }
9
10 public function addRenderer($name, RendererInterface $renderer)
11 {
12 $this->renderers[$name] = $renderer;
13 }
14 }
Of course, when the name is irrelevant, leave out the $name parameter. What matters is: whenever
anybody calls the addRenderer method and provides an object which is not an implementation of
RendererInterface, he will not succeed, because of the type-hint mismatch.
The service definition should now be changed to call the addRenderer() method for each of the
available renderers:
1 <service id="object_renderer" class="ObjectRenderer">
2 <call method="addRenderer">
3 <argument>domain_object</argument>
4 <argument type="service" id="domain_object_renderer" />
5 </call>
6 <call method="addRenderer">
7 <argument>user</argument>
8 <argument type="service" id="user_renderer" />
9 </argument>
10 </service>Service patterns 39
The best of both worlds
It may be better to combine the two options above, allowing developers to provide both an initial
collection of renderers through a constructor argument and/or to add renderers one by one using
the addRenderer() method:
1 class ObjectRenderer
2 {
3 private $renderers;
4 5
public function __construct(array $renderers)
6 {
7 foreach ($renderers as $name => $renderer) {
8 $this->addRenderer($name, $renderer);
9 }
10 }
11
12 public function addRenderer($name, RendererInterface $renderer)
13 {
14 $this->renderers[$name] = $renderer;
15 }
16 }
Service tags
We already have a nice setup for manually adding renderers, but what if other parts of your
application (like other bundles) should be able to register specific renderers? The best way to do
this is by using service tags:
1 <!-- in some other bundle -->
2 <service id="date_time_renderer" class="DateTimeRenderer">
3 <tag name="specific_renderer" alias="date_time" />
4 </service>
Each tag has a name, which you can choose yourself. Each tag can also have any number of extra
attributes (like alias above). These attributes allow you to further specify any requested behavior.
To collect services with these tags, you have to create a compiler pass like this one:Service patterns 40
1 namespace Matthias\RendererBundle\DependencyInjection\Compiler;
2 3
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
4 use Symfony\Component\DependencyInjection\ContainerBuilder;
5 use Symfony\Component\DependencyInjection\Reference;
6 7
class RenderersPass implements CompilerPassInterface
8 {
9 public function process(ContainerBuilder $container)
10 {
11 // collect all tagged services in the entire project
12 $taggedServiceIds
13 = $container ->findTaggedServiceIds('specific_renderer');
14
15 $objectRendererDefinition
16 = $container->getDefinition('object_renderer');
17
18 foreach ($taggedServiceIds as $serviceId => $tags) {
19
20 // services can have many tag elements with the same tag name
21 foreach ($tags as $tagAttributes) {
22
23 // call addRenderer() to register this specific renderer
24 $objectRendererDefinition
25 ->addMethodCall('addRenderer', array(
26 $tagAttributes['alias'],
27 new Reference($serviceId),
28 ));
29 }
30 }
31 }
32 }
Register this compiler pass in your bundle class:Service patterns 41
1 use Matthias\RendererBundle\DependencyInjection\Compiler\RenderersPass;
2 use Symfony\Component\DependencyInjection\ContainerBuilder;
3 4
class RendererBundle extends Bundle
5 {
6 public function build(ContainerBuilder $container)
7 {
8 $container->addCompilerPass(new RenderersPass());
9 }
10 }
Inside the process() method of the compiler pass, first all tags with the name specific_-
renderer are collected. This will result in an array of which the keys are service ids and the values
are arrays of attribute arrays. This is because each service definition can have multiple tags with the
same name (but maybe with different attributes).
Then, the service definition for the ObjectRenderer class is retrieved and while iterating over the
tags, a Reference is created which refers to each renderer service that is tagged as “specific_renderer”
and together with the provided value for alias, these are used as arguments to a call to the method
addRenderer().
All of this means that when the object_renderer service is requested, first of all an instance of
ObjectRenderer gets created. But afterwards, some calls are made to its addRenderer() method to
add the specific renderers tagged as specific_renderer.
Single method call
There are many possible approaches when collecting services in a compiler pass. For instance, you
can collect service references in an array and set them all at once, by adding a method call to
setRenderers():
1 class RenderersPass implements CompilerPassInterface
2 {
3 public function process(ContainerBuilder $container)
4 {
5 $taggedServiceIds = ...;
6 7
$objectRendererDefinition = ...;
8 9
$renderers = array();
10
11 foreach ($taggedServiceIds as $serviceId => $tags) {
12 foreach ($tags as $tagAttributes) {
13 $name = $tagAttributes['alias'];
14 $renderer = new Reference($serviceId);Service patterns 42
15 $renderers[$name] = $renderer;
16 }
17 }
18
19 $objectRendererDefinition
20 ->addMethodCall('setRenderers', array($renderers));
21 }
22 }
Replacing a single argument
When it’s possible - like in one of the examples above - to inject a collection of renderers as a
constructor argument, there is another way you can do this: set a constructor argument directly:
1 class RenderersPass implements CompilerPassInterface
2 {
3 public function process(ContainerBuilder $container)
4 {
5 $taggedServiceIds = ...;
6 7
$objectRendererDefinition = ...;
8 9
$renderers = array();
10
11 // collect service references
12 ...
13
14 $objectRendererDefinition->replaceArgument(0, $renderers);
15 }
16 }
Replacing arguments can only be done when you have defined them in the first place (for
instance as an empty argument):
1 <service id="object_renderer" class="ObjectRenderer">
2 <argument /><!-- specific renderers -->
3 </service>
Service ids instead of references
Whenever you request the object_renderer service, all the specific renderers are instantiated too.
Depending on the cost of instantiating these renderers it could be a good idea to add support for
lazy-loading. This can be accomplished by making the ObjectRenderer container-aware and by
injecting service ids, not the services themselves:Service patterns 43
1 class LazyLoadingObjectRenderer
2 {
3 private $container;
4 private $renderers;
5 6
public function __construct(ContainerInterface $container)
7 {
8 $this->container = $container;
9 }
10
11 public function addRenderer($name, $renderer)
12 {
13 $this->renderers[$name] = $renderer;
14 }
15
16 public function render($object)
17 {
18 foreach ($this->renderers as $name => $renderer) {
19 if (is_string($renderer)) {
20 // $renderer is assumed to be a service id
21 $renderer = $this->container->get($renderer);
22 }
23
24 // check if the renderer is an instance of RendererInterface
25 ...
26 }
27 }
28 }
The compiler pass should be modified to not pass references to services, but just service ids:
1 class RenderersPass implements CompilerPassInterface
2 {
3 public function process(ContainerBuilder $container)
4 {
5 $taggedServiceIds = ...;
6 7
$objectRendererDefinition = ...;
8 9
foreach ($taggedServiceIds as $serviceId => $tags) {
10 foreach ($tags as $tagAttributes) {
11 $objectRendererDefinition
12 ->addMethodCall('addRenderer', array(Service patterns 44
13 $tagAttributes['alias'],
14 $serviceId,
15 ));
16 }
17 }
18 }
19 }
Also don’t forget to provide the service container as a constructor argument:
1 <service id="object_renderer" class="LazyLoadingObjectRenderer">
2 <argument type="service" id="service_container" />
3 </service>
Of course, any of the strategies mentioned above can be used with this lazy-loading class (single
method call, multiple method calls or argument replacement).
Before you consider changing your class to make use of the service container directly, please
read the chapter Reduce coupling to the framework, specifically The performance issue.
6.4 Delegated creation
Instead of fully defining services upfront by a service definition with a class, arguments and method
calls, you can also leave the details to be figured out at runtime, by delegating the creation of services
to a factory method. Factory methods can be either static methods or object methods. In the first
case, you can provide the class name and the method name as attributes of the service definition:
1 <service id="some_service" class="ClassOfResultingObject"
2 factory-class="Some\Factory" factory-method="create">
3 <argument>...</argument>
4 </service>
When some_service is being requested for the first time, the service will be retrieved by calling
Some\Factory::create() statically with any arguments provided. The result will be stored in
memory, so the factory method is called only once.
Most factory methods nowadays are not static anymore, which means that the factory method
should be called on an instance of the factory itself. This instance should be defined as a service:Service patterns 45
1 <!-- a service created by some_factory_service -->
2 <service id="some_service" class="ClassOfResultingObject"
3 factory-service="some_factory_service" factory-method="create">
4 <argument>...</argument>
5 </service>
6 7
<!-- the factory -->
8 <service id="some_factory_service" class="Some\Factory">
9 </service>
Not so useful
Though the options for delegating the creation of services to other services seem really great, I
have not used them very often. They are almost exclusively useful when you are creating service
definitions for older PHP classes since in the (not so distant) past, creation logic was often hidden
inside static factory classes (remember Doctrine_Core::getTable()?).
My objection to factory classes with static factory methods is that static code is global code
and that executing that code may have side effects that can not be isolated (for instance in a test
scenario). Besides, any dependency of such a static factory method has to be by definition static
itself, which is also really bad for isolation and prevents you from replacing (part of) the creation
logic by your own code.
Factory objects (or factory services) are slightly better. However, the need for them very likely
points to some kind of design problem. A service should not need a factory, since it will be created
only once in a predetermined (and deterministic) way and from then on be perfectly reusable by
any other object. The only things that are dynamic about a service, should be the arguments of the
methods that are part of its public interface (see also State and context).
Sometimes useful
One particularly nice example of using a factory service and method for retrieving a service is the
case of a Doctrine repository. When you need one, you would normally inject an entity manager as
a constructor argument and later retrieve a specific repository:
1 use Doctrine\ORM\EntityManager;
2 3
class SomeClass
4 {
5 public function __construct(EntityManager $entityManager)
6 {
7 $this->entityManager = $entityManager;
8 }
9
10 public function doSomething()Service patterns 46
11 {
12 $repository = $this->entityManager->getRepository('User');
13
14 ...
15 }
16 }
But using a factory service and method you could directly inject the correct repository itself:
1 class SomeClass
2 {
3 public function __construct(UserRepository $userRepository)
4 {
5 $this->userRepository = $userRepository;
6 }
7 }
This is the corresponding service definition:
1 <service id="some_service" class="SomeClass">
2 <argument type="user_repository" />
3 </service>
4 5
<service id="user_repository" class="UserRepository"
6 factory-service="entity_manager" factory-method="getRepository">
7 <argument>User</argument>
8 </service>
By looking at the constructor arguments of SomeClass it is immediately clear that it needs a
User repository, which is much more specific and communicative than the earlier example in which
SomeClass needed an EntityManager. Besides making the class itself much cleaner, it will also make
it much easier to create a stand-in object for the repository when you are writing a unit test for this
class. Instead of creating a mock for both the entity manager and the repository, you only have to
create one for the repository itself.
6.5 Manually creating services
Usually you create services by loading service definitions from a file:Service patterns 47
1 use Symfony\Component\HttpKernel\DependencyInjection\Extension;
2 use Symfony\Component\Config\FileLocator;
3 use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
4 5
class SomeBundleExtension extends Extension
6 {
7 public function load(array $configs, ContainerBuilder $container)
8 {
9 $locator = new FileLocator(__DIR__.'/../Resources/config');
10 $loader = new XmlFileLoader($container, $locator);
11 $loader->load('services.xml');
12 }
13 }
But some services can not be defined in a configuration file. They should be defined dynamically,
because their name, class, arguments, tags, etc. are not fixed.
Definition
Manually creating a service definition means creating an instance of Definition, and optionally
providing a class name. The definition will get its identifier when it is set on the ContainerBuilder
instance:
1 use Symfony\Component\DependencyInjection\Definition;
2 3
$class = ...; // set a class name for the definition
4 5
$definition = new Definition($class);
6 7
$container->setDefinition('the_service_id', $definition);
The equivalent of this in XML would be:
1 <service id="the_service_id" class="...">
2 </service>
You can make the definition non-public if it only exists as a dependency of other services:
1 $definition->setPublic(false);
Arguments
When the service requires some constructor arguments, you may set them all at once:Service patterns 48
1 use Symfony\Component\DependencyInjection\Reference;
2 3
$definition->setArguments(array(
4 new Reference('logger') // reference to another service
5 true // boolean argument,
6 array(
7 'table_name' => 'users'
8 ) // array argument
9 ...
10 );
Arguments should be either references to other services, array values or scalar values (or a mix
of these). This is because all service definitions will eventually be stored as a simple PHP file. A
reference to another service can be created by using a Reference object with the id of the service
that should be injected.
You can also add the arguments one by one, in the right order:
1 $definition->addArgument(new Reference('logger'));
2 $definition->addArgument(true);
3 ...
Finally, when you are modifying an existing service definition with a list of arguments, you
could replace them by providing their numeric index:
1 $definition->setArguments(array(null, null));
2 3
...
4 5
$definition->replaceArgument(0, new Reference('logger'));
6 $definition->replaceArgument(1, true);
The equivalent in XML would be:
1 <service id="..." class="...">
2 <argument type="service" id="logger" />
3 <argument>true</argument>
4 </service>
Tags
There is another thing you may want to do when working with Definition objects: adding tags to
them. A tag consists of the name of the tag and an array of attributes. A definition can have multiple
tags with the same tag name:Service patterns 49
1 $definition->addTag('kernel.event_listener', array(
2 'event' => 'kernel.request'
3 );
4 $definition->addTag('kernel.event_listener', array(
5 'event' => 'kernel.response'
6 );
In XML you would write this like:
1 <service id="..." class="...">
2 <tag name="kernel.event_listener" event="kernel.request">
3 <tag name="kernel.event_listener" event="kernel.response">
4 </service>
Aliases
Before talking about what you can do with all this knowledge, there is one last thing you’ll need:
creating aliases for services:
1 $container->setAlias('some_alias', 'some_service_id');
Now whenever you request the service some_alias, you will in fact get the service some_-
service_id.
6.6 The Configuration class
Before we continue, I need to explain a few things about the Configuration class. You may have
noticed it earlier, and maybe you have even created one yourself.
Most of the times you will use a Configuration class to define all the possible configuration
options for your bundle (though the Config Component is highly decoupled so you can also use
anything described below in an entirely different context). The name of the class or its namespace
is actually irrelevant, as long as it implements ConfigurationInterface:
1 use Symfony\Component\Config\Definition\ConfigurationInterface;
2 use Symfony\Component\Config\Definition\Builder\TreeBuilder;
3 4
class Configuration implements ConfigurationInterface
5 {
6 public function getConfigTreeBuilder()
7 {
8 $treeBuilder = new TreeBuilder();
9 $rootNode = $treeBuilder->root('name_of_bundle');
10Service patterns 50
11 $rootNode
12 ->children()
13 // define configuration nodes
14 ...
15 ->end()
16 ;
17
18 return $treeBuilder;
19 }
20 }
There is one public method: getConfigTreeBuilder(). This method should return a TreeBuilder
instance which is a builder you use to describe all configuration options, including their validation
rules. Creating a config tree starts with defining a root node:
1 $rootNode = $treeBuilder->root('name_of_bundle');
The name of the root node should be the name of the bundle, without “bundle”, but lower-cased
and with underscores. So the node name for MatthiasAccountBundle will be matthias_account.
The root node is an array node. It can have any child node you like:
1 $rootNode
2 ->children()
3 ->booleanNode('auto_connect')
4 ->defaultTrue()
5 ->end()
6 ->scalarNode('default_connection')
7 ->defaultValue('default')
8 ->end()
9 ->end()
10 ;
Learn to write great config trees
When you want to become a proficient bundle creator, practice a lot with defining these
config nodes. Your bundle configurations will be much better and very flexible. Read more
about the configuration nodes in the documentation of the Config Component². Also take
a look at Configuration class from existing bundles and try to follow their example.
Usually, you will use an instance of the Configuration class inside a bundle’s extension class,
to process a given set of configuration arrays. These configuration arrays have been collected
by the kernel, by loading all the relevant configuration files (like config_dev.yml, config.yml,
parameters.yml, etc.).
²http://symfony.com/doc/current/components/config/definition.htmlService patterns 51
1 class MatthiasAccountExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9 }
10 }
The processConfiguration() method of the Extension class instantiates a Processor and
finalizes the config tree retrieved from the Configuration object. It then asks the processor to process
(validate and merge) the raw configuration arrays:
1 final protected function processConfiguration(
2 ConfigurationInterface $configuration,
3 array $configs
4 ) {
5 $processor = new Processor();
6 7
return $processor->processConfiguration($configuration, $configs);
8 }
When there were no validation errors, you can then use the configuration values in any way you
like. You can define or modify container parameters or service definitions based on the configuration
values. In the following chapters we will discuss many different ways to do this.
6.7 Dynamically add tags
Say you want to create a generic event listener, which listens to a configurable list of events, like
kernel.request, kernel.response, etc. This is what your Configuration class might look like:
1 use Symfony\Component\Config\Definition\ConfigurationInterface;
2 3
class Configuration implements ConfigurationInterface
4 {
5 public function getConfigTreeBuilder()
6 {
7 $treeBuilder = new TreeBuilder();
8 $rootNode = $treeBuilder->root('generic_listener');
9
10 $rootNodeService patterns 52
11 ->children()
12 ->arrayNode('events')
13 ->prototype('scalar')
14 ->end()
15 ->end()
16 ->end()
17 ;
18
19 return $treeBuilder;
20 }
21 }
It allows a list of event names to be configured like this:
1 generic_listener:
2 events: [kernel.request, kernel.response, ...]
The standard way to register an event listener would be to add tags to the event listener’s service
definition in services.xml:
1 <service id="generic_event_listener" class="...">
2 <tag name="kernel.event_listener" event="..." method="onEvent" />
3 <tag name="kernel.event_listener" event="..." method="onEvent" />
4 </service>
But in this situation, we don’t know in advance to which events the listener should listen, so
these events can not be defined in a configuration file. Luckily - as we saw earlier - we can add tags
to service definitions on the fly. This can be done inside the container extension:
1 class GenericListenerExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9
10 // load services.xml
11 $loader = ...;
12 $loader->load('services.xml');
13
14 $eventListener = $container
15 ->getDefinition('generic_event_listener');Service patterns 53
16
17 foreach ($processedConfig['events'] as $eventName) {
18 // add a kernel.event_listener tag for each event
19 $eventListener
20 ->addTag('kernel.event_listener', array(
21 'event' => $eventName,
22 'method' => 'onEvent'
23 ));
24 }
25 }
26 }
There is one extra step you might take to prevent a dangling listener service when there are no
events to which it should listen:
1 if (empty($processedConfig['events'])) {
2 $container->removeDefinition('generic_event_listener');
3 }
6.8 Strategy pattern for loading exclusive services
Often bundles provide multiple ways of doing a single thing. For instance, a bundle that provides
some kind of mailbox functionality may have different storage implementations, like one storage
manager for Doctrine ORM and one for MongoDB. To make the choice for a specific storage manager
configurable, create a Configuration class like this:
1 use Symfony\Component\Config\Definition\ConfigurationInterface;
2 3
class Configuration implements ConfigurationInterface
4 {
5 public function getConfigTreeBuilder()
6 {
7 $treeBuilder = new TreeBuilder();
8 $rootNode = $treeBuilder->root('browser');
9
10 $rootNode
11 ->children()
12 ->scalarNode('storage_manager')
13 ->validate()
14 ->ifNotInArray(array('doctrine_orm', 'mongo_db')
15 ->thenInvalid('Invalid storage manager')
16 ->end()
17 ->end()Service patterns 54
18 ->end()
19 ;
20
21 return $treeBuilder;
22 }
23 }
Then given there are two service definition files for each of the storage managers, like
doctrine_orm.xml:
1 <services>
2 <service id="mailbox.doctrine_orm.storage_manager" class="...">
3 </service>
4 </services>
And mongo_db.xml:
1 <services>
2 <service id="mailbox.mongo_db.storage_manager" class="...">
3 </service>
4 </services>
You could then load either of these files by doing something like this in your container extension:
1 class MailboxExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9
10 // create an XmlLoader
11 $loader = ...;
12
13 // load only the services for the given storage manager
14 $storageManager = $processedConfig['storage_manager'];
15 $loader->load($storageManager.'.xml');
16
17 // make the specific storage manager available as the general one
18 $container->setAlias(
19 'mailbox.storage_manager',
20 'mailbox.'.$storageManager.'.storage_manager'Service patterns 55
21 );
22 }
23 }
A convenient alias is created in the end to allow other parts of the application to just request
the mailbox.storage_manager service, instead of worrying about the storage-specific service that
should be used. However, the way this is done is too rigid: the id of each specific storage manager
service should conform to the pattern mailbox.{storageManagerName}.storage_manager. It would
be better to define the alias inside the service definition files themselves:
1 <services>
2 <service id="mailbox.doctrine_orm.storage_manager" class="...">
3 </service>
4 5
<service id="storage_manager"
6 alias="mailbox.doctrine_orm.storage_manager">
7 </service>
8 </services>
Using the strategy pattern for loading service definitions has many advantages:
• Only the services that are useful in the current application will be loaded. When you don’t
have a MongoDB server up and running, there will be no services that accidentally refer to it.
• The setup is open for extension, since you can add the name of another storage manager to
the list in the Configuration class and then add a service definition file with the necessary
services and an alias.
6.9 Loading and configuring additional services
Say you have a bundle dedicated to input filtering. Probably you offer several different services, like
services for filtering form data, and services for filtering data stored using Doctrine ORM. It should
be possible to enable or disable any of these services or collections of services at any time because
they may not all be applicable to your specific situation. There is a handy shortcut for configuration
definitions to accomplish a thing like this:Service patterns 56
1 class Configuration implements ConfigurationInterface
2 {
3 public function getConfigTreeBuilder()
4 {
5 $treeBuilder = new TreeBuilder();
6 $rootNode = $treeBuilder->root('input_filter');
7 8
$rootNode
9 ->children()
10 ->arrayNode('form_integration')
11 // will be enabled by default
12 ->canBeDisabled()
13 ->end()
14 ->arrayNode('doctrine_orm_integration')
15 // will be disabled by default
16 ->canBeEnabled()
17 ->end()
18 ->end()
19 ;
20
21 return $treeBuilder;
22 }
23 }
With a configuration tree like this, you can enable or disable specific parts of the bundle in
config.yml:
1 input_filter:
2 form_integration:
3 enabled: false
4 doctrine_orm_integration:
5 enabled: true
Inside your container extension you can then load the appropriate services:Service patterns 57
1 class InputFilterExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9
10 if ($processedConfig['doctrine_orm_integration']['enabled']) {
11 $this->loadDoctrineORMIntegration(
12 $container,
13 $processedConfig['doctrine_orm_integration']
14 );
15 }
16
17 if ($processedConfig['form_integration']['enabled']) {
18 $this->loadFormIntegration(
19 $container,
20 $processedConfig['form_integration']
21 );
22 }
23
24 ...
25 }
26
27 private function loadDoctrineORMIntegration(
28 ContainerBuilder $container,
29 array $configuration
30 ) {
31 // load services, etc.
32 ...
33 }
34
35 private function loadFormIntegration(
36 ContainerBuilder $container,
37 array $configuration
38 ) {
39 ...
40 }
41 }
Each of the stand-alone parts of the bundle can be loaded separately like this.Service patterns 58
A cleaner configuration class
One or two of these stand-alone bundle parts can be easily handled, but soon the Configuration
class will contain many lines of code in just one method. You can clean this up a bit by using the
append() method in combination with some private methods:
1 class Configuration implements ConfigurationInterface
2 {
3 public function getConfigTreeBuilder()
4 {
5 $treeBuilder = new TreeBuilder();
6 7
$rootNode = $treeBuilder->root('input_filter');
8 9
$rootNode
10 ->append($this->createFormIntegrationNode())
11 ->append($this->createDoctrineORMIntegrationNode())
12 ;
13
14 return $treeBuilder;
15 }
16
17 private function createDoctrineORMIntegrationNode()
18 {
19 $builder = new TreeBuilder();
20
21 $node = $builder->root('doctrine_orm_integration');
22
23 $node
24 ->canBeEnabled()
25 ->children()
26 // maybe add some more configuration
27 ...
28 ->end();
29
30 return $node;
31 }
32
33 private function createFormIntegrationNode()
34 {
35 ...
36 }
37 }Service patterns 59
6.10 Configure which services to use
Instead of using the Strategy pattern for loading services you may also allow developers to manually
configure a service they want to use. For example, if your bundle needs some kind of encrypter
service and the bundle does not provide one itself, you would want to ask the developer to provide
the encrypter by its service id:
1 matthias_security:
2 encrypter_service: my_encrypter_service_id
Your Configuration class should then look like this:
1 class Configuration implements ConfigurationInterface
2 {
3 public function getConfigTreeBuilder()
4 {
5 $treeBuilder = new TreeBuilder();
6 $rootNode = $treeBuilder->root('matthias_security');
7 8
$rootNode
9 ->children()
10 ->scalarNode('encrypter_service')
11 ->isRequired()
12 ->end()
13 ->end()
14 ;
15
16 return $treeBuilder;
17 }
18 }
Inside the bundle’s extension class, you could then create an alias for the configured service.
1 class MatthiasSecurityExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9
10 $container->setAlias(Service patterns 60
11 'matthias_security.encrypter',
12 $processedConfig['encrypter_service']
13 );
14 }
15 }
So even though the service id of the encrypter may originally be anything, now you have a stable
reference to it - an alias - which you can use inside any of your bundle’s service definitions:
1 <service id="matthias_security.encrypted_data_manager" class="...">
2 <argument type="service" id="matthias_security.encrypter" />
3 </service>
Of course the assumption here is that the manually configured encrypter service is a valid
encrypter object. You can not be sure at configuration time that this is true, so you will have to
verify this at runtime. The usual way to do this would be to add the appropriate type-hint to classes
of services that use the encrypter service:
1 class EncryptedDataManager
2 {
3 public function __construct(EncrypterInterface $encrypter)
4 {
5 // $encrypter is a valid encrypter
6 }
7 }
6.11 Completely dynamic service definitions
There are situations when you know almost nothing about the services you need, until you have
processed the configuration. Say you want the users of your bundle to define a set of resources as
services. These resources can be of type directory or file. You want to create these services on the
fly since they differ per application and you need to collect them using a custom service tag, called
resource. Your Configuration class may look like this:Service patterns 61
1 class Configuration implements ConfigurationInterface
2 {
3 public function getConfigTreeBuilder()
4 {
5 $treeBuilder = new TreeBuilder();
6 $rootNode = $treeBuilder->root('resource_management');
7 8
$rootNode
9 ->children()
10 ->arrayNode('resources')
11 ->prototype('array')
12 ->children()
13 ->scalarNode('type')
14 ->validate()
15 ->ifNotInArray(
16 array('directory', 'file')
17 )
18 ->thenInvalid('Invalid type')
19 ->end()
20 ->end()
21 ->scalarNode('path')
22 ->end()
23 ->end()
24 ->end()
25 ->end()
26 ->end()
27 ;
28
29 return $treeBuilder;
30 }
31 }
An example resource configuration:Service patterns 62
1 resource_management:
2 resources:
3 global_templates:
4 type: directory
5 path: Resources/views
6 app_kernel:
7 type: file
8 path: AppKernel.php
When the resources are defined like this, you can create service definitions for them in the
container extension:
1 class ResourceManagementExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $processedConfig = $this->processConfiguration(
6 new Configuration(),
7 $configs
8 );
9
10 $resources = $processedConfig['resources'];
11
12 foreach ($resources as $name => $resource) {
13 $this->addResourceDefinition($container, $name, $resource);
14 }
15 }
16
17 private function addResourceDefinition(
18 ContainerBuilder $container,
19 $name,
20 array $resource
21 ) {
22 // determine the class
23 $class = $this->getResourceClass($resource['type']);
24
25 $definition = new Definition($class);
26
27 // add a specific tag
28 $definition->addTag('resource');
29
30 $serviceId = 'resource.'.$name;
31Service patterns 63
32 $container->setDefinition($serviceId, $definition);
33 }
34
35 private function getResourceClass($type)
36 {
37 if ($type === 'directory') {
38 return 'Resource\Directory';
39 } elseif ($type === 'file') {
40 return 'Resource\File';
41 }
42
43 throw new \InvalidArgumentException('Type not supported');
44 }
45 }
When these manually created service definitions need arguments, method calls, etc. use the
techniques described above to add these dynamically too.
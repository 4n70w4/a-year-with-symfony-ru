## Организация слоёв приложения

### 8.1 Slim controllers

In many Symfony applications, controller code ends up looking like this:
1 namespace Matthias\AccountBundle\Controller;
2 3
use Symfony\Bundle\FrameworkBundle\Controller;
4 use Symfony\Component\HttpFoundation\Request;
5 use Matthias\AccountBundle\Entity\Account;
6 7
class AccountController extends Controller
8 {
9 public function newAction(Request $request)
10 {
11 $account = new Account();
12
13 $form = $this->createForm(new AccountType(), $account);
14
15 if ($request->isMethod('POST')) {
16 $form->bind($request);
17
18 if ($form->isValid()) {
19 $confirmationCode = $this
20 ->get('security.secure_random')
21 ->nextBytes(4);
22 $account
23 ->setConfirmationCode(md5($confirmationCode));
24
25 $entityManager = $this->getDoctrine()->getManager();
26 $entityManager->persist($account);
27 $entityManager->flush();
28
29 $this->sendAccountConfirmationMessage($account);
30
31 return $this->redirect($this->generateUrl('mailbox_index'));
32 }
33 }
34Organizing application layers 74
35 return array(
36 'form' => $form->createView(),
37 );
38 }
39
40 private function sendAccountConfirmationMessage(Account $account)
41 {
42 $message = \Swift_Message::newInstance()
43 ->setSubject('Confirm account')
44 ->setFrom('noreply@matthias.com')
45 ->setTo($account->getEmailAddress())
46 ->setBody('Welcome! ...');
47
48 $this->get('mailer')->send($message);
49 }
50 }
When you look at the newAction controller you can see that there is a form type AccountType,
the data class of which is Matthias\AccountBundle\Entity\Account. After binding and validating
the form, a confirmation code will be generated, and the account object will be persisted. Then a
confirmation mail is being created and sent.
There is too much going on here, the result of which is that:
1. It is impossible to separate reusable code from project-specific code here. Suppose you want
to reuse part of the account creation logic in a future project. This is only be possible by copypasting the code from this controller into your new project. This is called immobility: code
can not be easily transferred to another application.
2. It is also impossible to reuse account creation logic in some other part of this application,
since everything is written inline, inside the controller. Let’s say you have to create a console
command for importing a CSV file containing account data of users of an older version of
the application. You have no way to build such a thing without (again) copy-pasting part of
the code to another class. I call this controller-centrism - code is too much formed around a
controller.
3. The code is tightly coupled to two other libraries: SwiftMailer and Doctrine ORM. It is
impossible to run this code without either of them, even though there are many alternatives
for both. This is called tight coupling and is generally not a good thing.
In order to be able to reuse code in another application, or to reuse code in another part of the
same application, or to switch from mailer or storage manager implementation, you need to split
the code into multiple classes with single responsibilities.Organizing application layers 75

### 8.2 Form handlers

The first step is: delegating the form handling to a specialized form handler. This form handler is a
very simple class, which processes the form and does whatever is expected. The result of the first
refactoring is the CreateAccountFormHandler:
1 namespace Matthias\AccountBundle\Form\Handler;
2 3
use Symfony\Component\HttpFoundation\Request;
4 use Symfony\Component\Form\FormInterface;
5 use Doctrine\ORM\EntityManager;
6 use Matthias\AccountBundle\Entity\Account;
7 use Symfony\Component\Security\Core\Util\SecureRandomInterface;
8 9
class CreateAccountFormHandler
10 {
11 private $entityManager;
12 private $secureRandom;
13
14 public function __construct(
15 EntityManager $entityManager,
16 SecureRandomInterface $secureRandom
17 ) {
18 $this->entityManager = $entityManager;
19 $this->secureRandom = $secureRandom;
20 }
21
22 public function handle(FormInterface $form, Request $request)
23 {
24 if (!$request->isMethod('POST')) {
25 return false;
26 }
27
28 $form->bind($request);
29
30 if (!$form->isValid()) {
31 return false;
32 }
33
34 $validAccount = $form->getData();
35
36 $this->createAccount($validAccount);
37Organizing application layers 76
38 return true;
39 }
40
41 private function createAccount(Account $account)
42 {
43 $confirmationCode = $this
44 ->secureRandom
45 ->nextBytes(4);
46
47 $account
48 ->setConfirmationCode(md5($confirmationCode));
49
50 $this->entityManager->persist($account);
51 $this->entityManager->flush();
52 }
53 }
The service definition for this form handler would look like:
1 <service id="matthias_account.create_account_form_handler"
2 class="Matthias\AccountBundle\Form\Handler\CreateAccountFormHandler">
3 <argument type="service" id="entity_manager" />
4 <argument type="service" id="security.secure_random" />
5 </service>
As you can see, the handle() method returns true if it was able to do everything it intended to
do, and false if anything went wrong in the process and the form should be rendered again. Using
this simple mechanism, the controller can be slimmed down a lot:
1 class AccountController extends Controller
2 {
3 public function newAction(Request $request)
4 {
5 $account = new Account();
6 7
$form = $this->createForm(new AccountType(), $account);
8 9
$formHandler = $this
10 ->get('matthias_account.create_account_form_handler');
11
12 if ($formHandler->handle($form, $request)) {
13 $this->sendAccountConfirmationMessage($account);
14Organizing application layers 77
15 return $this->redirect($this->generateUrl('mailbox_index'));
16 }
17
18 return array(
19 'form' => $form->createView(),
20 );
21 }
22 }
Form handlers should be very simple and should throw no exceptions that are intended as
feedback to the user. Any feedback you would want to provide from within the form handler should
be created by adding extra form errors to the form and returning false to indicate that there was a
problem:
1 use Symfony\Component\Form\FormError;
2 3
public function handle(FormInterface $form, Request $request)
4 {
5 if (...) {
6 $form->addError(new FormError('There was a problem'));
7 8
return false;
9 }
10 }
However, keep in mind that ideally any error related to a form is a validation error. This means
that the form handler should not have to do any validation other than calling isValid(). Just create
any kind of validation constraint¹ and a corresponding validator to ensure that all checks for validity
are centrally available and therefore reusable.

### 8.3 Domain managers

The form handler (and maybe the form type), would be a great candidate for reuse. However, there is
still too much happening in the form handler. Considering that the responsibility of a form handler
is “to handle a form”, it is likely that creating a confirmation code is too much. Also, talking directly
to the persistence layer (in this case Doctrine ORM) is too much to ask of a simple form handler.
The solution for this problem is to delegate domain-related tasks to domain managers. These
managers may talk directly to the persistence layer. Let’s call the domain manager for Accountrelated tasks the AccountManager. It would look something like this:
¹http://symfony.com/doc/master/cookbook/validation/custom_constraint.htmlOrganizing application layers 78
1 namespace Matthias\AccountBundle\DomainManager;
2 3
use Symfony\Component\HttpFoundation\Request;
4 use Symfony\Component\Form\FormInterface;
5 use Doctrine\ORM\EntityManager;
6 use Matthias\AccountBundle\Entity\Account;
7 use Symfony\Component\Security\Core\Util\SecureRandomInterface;
8 9
class AccountManager
10 {
11 private $entityManager;
12 private $secureRandom;
13
14 public function __construct(
15 EntityManger $entityManager,
16 SecureRandomInterface $secureRandom
17 ) {
18 $this->entityManager = $entityManager;
19 $this->secureRandom = $secureRandom;
20 }
21
22 public function createAccount(Account $account)
23 {
24 $confirmationCode = $this
25 ->secureRandom
26 ->nextBytes(4);
27
28 $account
29 ->setConfirmationCode(md5($confirmationCode));
30
31 $this->entityManager->persist($account);
32 $this->entityManager->flush();
33 }
34 }
Now the form handler just uses the AccountManager to really create the account:Organizing application layers 79
1 class CreateAccountFormHandler
2 {
3 private $accountManager;
4 5
public function __construct(AccountManager $accountManager)
6 {
7 $this->accountManager = $accountManager;
8 }
9
10 public function handle(FormInterface $form, Request $request)
11 {
12 ...
13
14 $validAccount = $form->getData();
15
16 $this->accountManager->createAccount($validAccount);
17 }
18 }
These are the corresponding service definitions for the form handler and domain manager
classes:
1 <service id="matthias_account.create_account_form_handler"
2 class="Matthias\AccountBundle\Form\Handler\CreateAccountFormHandler">
3 <argument type="service" id="matthias_account.account_manager" />
4 </service>
5 6
<service id="matthias_account.account_manager"
7 class="Matthias\AccountBundle\DomainManager\AccountManager">
8 <argument type="service" id="entity_manager" />
9 <argument type="service" id="security.secure_random" />
10 </service>
Domain managers can do anything a domain object itself could not accomplish. You can use it
to encapsulate logic about:
• Creating objects and persisting them
• Creating relations between objects (like connecting two users)
• Duplicating objects
• Removing objects
• …Organizing application layers 80

### 8.4 Events

As you may have noticed, inside the controller a confirmation mail was sent after creating the new
account. Things like this are better off with some delegation. Sending a mail is probably not the
only thing that should be done when there is a new account. Maybe some settings object has to be
pre-populated with default settings for the new user, or maybe a notification should be sent to the
owner of the site that there is a new user of his product.
This is a perfect use-case for an event-driven approach: it seems that inside the AccountManager a
generic event takes place, (namely, “a new account has been created”). Other parts of the application
should be allowed to respond to this fact. In this case there should be at least an event listener that
sends the confirmation mail to the new user.
To be able to dispatch a custom event with some specific data you need to create your own event
class, which extends from the generic Event class:
1 namespace Matthias\AccountBundle\Event;
2 3
use Symfony\Component\EventDispatcher\Event;
4 5
class AccountEvent extends Event
6 {
7 private $account;
8 9
public function __construct(Account $account)
10 {
11 $this->account = $account;
12 }
13
14 public function getAccount()
15 {
16 return $this->account;
17 }
18 }
Then we need to think of a name for the event - let’s call it matthias_account.new_account_-
created. It’s generally best practice to store this name as a constant of a dedicated class in your
bundle:Organizing application layers 81
1 namespace Matthias\AccountBundle\Event;
2 3
class AccountEvents
4 {
5 const NEW_ACCOUNT_CREATED = 'matthias_account.new_account_created';
6 }
Now we need to modify the AccountManager to actually dispatch this matthias_account.new_-
account_created event:
1 namespace Matthias\AccountBundle\DomainManager;
2 3
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
4 use Matthias\AccountBundle\Event\AccountEvents;
5 use Matthias\AccountBundle\Event\AccountEvent;
6 7
class AccountManager
8 {
9 ...
10
11 private $eventDispatcher;
12
13 public function __construct(
14 ...
15 EventDispatcherInterface $eventDispatcher
16 ) {
17 ...
18
19 $this->eventDispatcher = $eventDispatcher;
20 }
21
22 public function createAccount(Account $account)
23 {
24 ...
25
26 $this->eventDispatcher->dispatch(
27 AccountEvents::NEW_ACCOUNT_CREATED,
28 new AccountEvent($account)
29 );
30 }
31 }
Don’t forget to add the event_dispatcher service as an argument to the service definition of
the AccountManager:Organizing application layers 82
1 <service id="matthias_account.account_manager"
2 class="Matthias\AccountBundle\DomainManager\AccountManager">
3 <argument type="service" id="entity_manager" />
4 <argument type="service" id="security.secure_random" />
5 <argument type="service" id="event_dispatcher" />
6 </service>
The event listener for the matthias_account.new_account_created event will look like this:
1 namespace Matthias\AccountBundle\EventListener;
2 3
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
4 use Matthias\AccountBundle\Event\AccountEvents;
5 use Matthias\AccountBundle\Event\AccountEvent;
6 7
class SendConfirmationMailListener implements EventSubscriberInterface
8 {
9 private $mailer;
10
11 public static function getSubscribedEvents()
12 {
13 return array(
14 AccountEvents::NEW_ACCOUNT_CREATED => 'onNewAccount'
15 );
16 }
17
18 public function __construct(\SwiftMailer $mailer)
19 {
20 $this->mailer = $mailer;
21 }
22
23 public function onNewAccount(AccountEvent $event)
24 {
25 $this->sendConfirmationMessage($event->getAccount());
26 }
27
28 private function sendConfirmationMessage(Account $account)
29 {
30 $message = \Swift_Message::newInstance();
31
32 ...
33
34 $this->mailer->send($message);Organizing application layers 83
35 }
36 }
Since this event listener needs the mailer to do its work, we need to inject it by adding an
argument to its service definition. In fact, we also have to add a tag kernel.event_subscriber
which registers the SendConfirmationMailListener as an event subscriber:
1 <service id="life_online_account.send_confirmation_mail_listener"
2 class="Matthias\AccountBundle\EventListener\SendConfirmationMailListener">
3 <argument type="service" id="mailer" />
4 <tag name="kernel.event_subscriber" />
5 </service>
Event listener best practices
An event listener should be named after the thing it does, not after the event it listens
to. So instead of naming an event listener NewAccountEventListener, you should name it
SendConfirmationMailListener. This also helps other developers when they are trying to
find the place where a confirmation mail is being sent.
Also, when something else should happen when an event occurs, like sending a mail to the
owner of the site, you should create another listener service for it, instead of adding more
code to the existing listener. Enabling or disabling specific listeners will be much easier,
and maintainability increases, because you won’t accidentally change existing behavior.
Persistence events
You may recall that the AccountManager (a domain manager) generated a confirmation code for the
account, right before persisting it:
1 class AccountManager
2 {
3 private $entityManager;
4 private $secureRandom;
5 6
public function __construct(
7 EntityManger $entityManager,
8 SecureRandomInterface $secureRandom
9 ) {
10 $this->entityManager = $entityManager;
11 $this->secureRandom = $secureRandom;
12 }
13Organizing application layers 84
14 public function createAccount(Account $account)
15 {
16 $confirmationCode = $this
17 ->secureRandom
18 ->nextBytes(4);
19
20 $account
21 ->setConfirmationCode(md5($confirmationCode));
22
23 $this->entityManager->persist($account);
24 $this->entityManager->flush();
25 }
26 }
This is not such a good idea. Again: an account may be created in another place and then it will
not have a confirmation code at all. From a “responsibility” point of view, looking at the dependencies
of the AccountManager, it is quite strange that it should have a SecureRandomInterface object as a
dependency: why would it need that, when it just knows how to create an account?
This logic should be moved to some other place, closer to the real event of persisting a new
account. Most persistence layers support something like events or behaviors by which you can hook
into the process of storing new objects, updating or removing existing objects.
For Doctrine ORM it starts with an event subscriber:
1 use Doctrine\Common\EventSubscriber;
2 use Doctrine\ORM\Event\LifecycleEventArgs;
3 4
class CreateConfirmationCodeEventSubscriber implements EventSubscriber
5 {
6 private $secureRandom;
7 8
public function __construct(SecureRandomInterface $secureRandom)
9 {
10 $this->secureRandom = $secureRandom;
11 }
12
13 public function getSubscribedEvents()
14 {
15 return array(
16 'prePersist'
17 );
18 }
19
20 public function prePersist(LifecycleEventArgs $event)Organizing application layers 85
21 {
22 // this will be called for *each* new entity
23
24 $entity = $event->getEntity();
25 if (!($entity instanceof Account)) {
26 return;
27 }
28
29 $this->createConfirmationCodeFor($entity);
30 }
31
32 private function createConfirmationCodeFor(Account $account)
33 {
34 $confirmationCode = $this
35 ->secureRandom
36 ->nextBytes(4);
37
38 $account
39 ->setConfirmationCode(md5($confirmationCode));
40 }
41 }
You can register this event subscriber using the tag doctrine.event_subscriber:
1 <service id="create_confirmation_code_listener" class="...">
2 <tag name="doctrine.event_subscriber" />
3 </service>
There are more events², like postPersist, preUpdate, preFlush, etc. which allow you to respond
to many of the important events in the lifecycle of entities. Specifically preUpdate can be very handy,
to determine if someone has changed the value of a specific field:
1 use Doctrine\ORM\Event\PreUpdateEventArgs;
2 3
class CreateConfirmationCodeEventSubscriber implements EventSubscriber
4 {
5 public function getSubscribedEvents()
6 {
7 return array(
8 'preUpdate'
9 );
10 }
²http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#listening-and-subscribing-to-lifecycle-eventsOrganizing application layers 86
11
12 public function preUpdate(PreUpdateEventArgs $event)
13 {
14 $entity = $event->getEntity();
15 if (!($entity instanceof Account)) {
16 return;
17 }
18
19 if ($event->hasChangedField('emailAddress')) {
20 // create a new confirmation code
21 $confirmationCode = ...;
22 $event->setNewValue('confirmationCode', $confirmationCode);
23 }
24 }
As you can see, listeners to the preUpdate event receive a special event object. You can use it to
examine which fields have changed and to add some more changes.
Doctrine event gotchas
Some things that are not immediately clear when it comes to Doctrine events:
• The preUpdate event is only dispatched when the value of some field was changed,
not necessarily any time you call flush() on the entity manager.
• The prePersist event is only dispatched when an entity was not persisted before.
• In certain situations you are too late to make any changes to an object, so when you
do, you need to make the UnitOfWork recompute the changes manually:
1 $entity = $event->getEntity();
2 $className = get_class($entity);
3 $entityManager = $event->getEntityManager();
4 $classMetadata = $entityManager->getClassMetadata($className);
5 $unitOfWork = $entityManager->getUnitOfWork();
6 $unitOfWork->recomputeSingleEntityChangeSet($classMetadata, $entity);
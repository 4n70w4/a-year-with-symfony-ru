## Шаблоны создания параметров

7 Parameter patterns
The service container has service definitions and parameters. Parameters are simple values that
can consist of constant scalar values and arrays, in any combination. So 'matthias' would be
a valid parameter, and so would 23 be. But also array(23 => 'matthias'), array(23 =>
array('matthias')), etc.
You can define parameters using the key of your choice. The naming convention however would
be: name_of_your_bundle_without_bundle.parameter_name. These parameters can be defined in
various places.
7.1 Parameters.yml
Some of the more essential parameters of your application (which probably have no default
value) can be found in /app/config/parameters.yml. Parameters are loaded together with service
definitions and configuration values for container extensions. That is why the standard config.yml
starts with these lines:
1 imports:
2 - { resource: parameters.yml }
3 - { resource: security.yml }
4 5
framework:
6 secret: %secret%
7 ...
First parameters.yml and security.yml will be imported. The file parameters.yml starts with:
1 parameters:
2 database_driver: pdo_mysql
3 ...
And security.yml starts with:
1 security:
2 encoders:
3 Symfony\Component\Security\Core\User\User: plaintext
4 ...
These files will be imported as they are. So config.yml could just as well look like:Parameter patterns 65
1 parameters:
2 ...
3 security:
4 ...
5 framework:
6 ...
Since all configuration arrays will be merged in the end, it is possible in config.yml to override
any parameter defined in parameters.yml:
1 parameters:
2 ... # loaded from parameters.yml
3 database_driver: pdo_sqlite
Even service definitions can be created within config.yml (or any service container configuration file for that matter):
1 parameters:
2 ...
3 services:
4 some_service_id:
5 class: SomeClass
7.2 Parameter resolving
Values defined in config.yml, or parameters.yml but also in service definitions and definition
arguments can contain placeholders for values that should have been defined as parameters. When
the service container gets compiled, values containing placeholders will be resolved. For instance in
the example above we defined the database_driver parameter in parameters.yml. In config.yml
we can refer to this parameter using the %database_driver% placeholder:
1 doctrine:
2 dbal:
3 driver: %database_driver%
When creating service definitions, the Symfony bundles usually take the same approach when
it comes to the class names used:Parameter patterns 66
1 <parameters>
2 <parameter key="form.factory.class">
3 Symfony\Component\Form\FormFactory
4 </parameter>
5 </parameters>
6 7
<service id="form.factory" class="%form.factory.class%">
8 </service>
Parameters for class names
Using parameters for class names would allow other parts of the application to replace the
parameter, instead of directly modifying the service definition. It is not very likely however
that this will happen, and when every service definition has its class in a parameter, this parameter also ends up in the final service container, so that even at runtime you could call
$container->getParameter('form.factory.class') and retrieve the class name of the form
factory. This seems very redundant to me and I would not recommend it when creating your own
service definitions.
Whenever you would want to change the class of a definition, you could do this inside a compiler
pass:
1 use Symfony\Component\DependencyInjection\ContainerBuilder;
2 use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
3 4
class ReplaceClassCompilerPass implements CompilerPassInterface
5 {
6 public function process(ContainerBuilder $container)
7 {
8 $myCustomFormFactoryClass = ...;
9
10 $container
11 ->getDefinition('form.factory')
12 ->setClass($myCustomFormFactoryClass);
13 }
14 }
Manually resolving parameters
When you are using parameters in your bundle extension (or in a compiler pass), the values of these
parameters are not fully resolved yet. For example, your bundle may define a parameter my_cache_-
dir, referring to the %kernel.cache_dir% which contains the location of the cache directory used
by the kernel:Parameter patterns 67
1 parameters:
2 my_cache_dir: %kernel.cache_dir%/my_cache
In the load() method of your container extension you would like to create this directory if it
does not already exist:
1 class MyExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 $myCacheDir = $container->getParameter('my_cache_dir');
6 7
...
8 }
9 }
When the load() method gets called, the my_cache_dir parameter is still literally “%kernel.cache_dir%/my_cache”. Luckily you can use the ParameterBag::resolveValue() method to
replace all placeholders with their current values:
1 $myCacheDir = $container->getParameter('my_cache_dir');
2 3
$myCacheDir = $container->getParameterBag()->resolveValue($myCacheDir);
4 5
// now you can create the cache directory
6 mkdir($myCacheDir);Parameter patterns 68
Kernel parameters
By itself, the kernel adds these parameters to the container, before loading the bundles:
kernel.root_dir
The location of the kernel class (e.g. /app)
kernel.environment
The environment (e.g. dev, prod, etc.)
kernel.debug
Debug mode (true or false)
kernel.name
The name of the directory the kernel is in (e.g. app)
kernel.cache_dir
The location of the cache directory (e.g. /app/cache/dev)
kernel.logs_dir
the location of the logs directory (e.g. /app/logs)
kernel.bundles
a list of enabled bundles (e.g. array('FrameworkBundle' =>
'Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle', ...),
kernel.charset
the character set used for responses (e.g. UTF-8)
kernel.container_class
the name of the service container class (e.g. appDevDebugProjectContainer), to be
found in kernel.cache_dir.
The kernel also adds any environment variable that starts with SYMFONY__. Before doing
so, it replaces __ with . in the names of these variables, so SYMFONY__DATABASE__USER will
be available as the database.user parameter.
7.3 Define parameters in a container extension
Many times you will find yourself in the following situation:
• You want the developer to provide some value for your bundle’s configuration in config.yml.
• You then need to use this specific value as an argument for one of the services of your bundle.
Say you have a BrowserBundle and you want the developer to provide a timeout value for the
browser service:Parameter patterns 69
1 browser:
2 timeout: 30
Your bundle’s Configuration class should look like:
1 class Configuration implements ConfigurationInterface
2 {
3 public function getConfigTreeBuilder()
4 {
5 $treeBuilder = new TreeBuilder();
6 $rootNode = $treeBuilder->root('browser');
7 8
$rootNode
9 ->children()
10 ->scalarNode('timeout')
11 ->end()
12 ->end()
13 ;
14
15 return $treeBuilder;
16 }
Then inside your container extension you need to process the configuration values from
config.yml and the likes:
1 class BrowserExtension extends Extension
2 {
3 public function load(array $configs, ContainerBuilder $container)
4 {
5 // load the service definitions
6 $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
7 $loader = new XmlFileLoader($container, $fileLocator);
8 $loader->load('services.xml');
9
10 // process the configuration
11 $processedConfig = $this->processConfiguration(
12 new Configuration(),
13 $configs
14 );
15 }
16 }
Your browser service is defined in services.xml:Parameter patterns 70
1 <service id="browser" class="...">
2 <argument>%browser.timeout%</argument>
3 </service>
The value for timeout that the user has provided in config.yml (“30”) will be available in the
container extension’s load() method as $processedConfig['timeout'] so the only thing you need
to do in that method is copy this value as a parameter to the service container:
1 $container->setParameter('browser.timeout', $processedConfig['timeout']);
7.4 Override parameters with a compiler pass
Sometimes you want to analyze and override a parameter defined in another bundle, after this
bundle has had the chance to define it. For example you may want to modify the hierarchy of user
roles defined in security.yml, which will be available as the container parameter security.role_-
hierarchy.roles. This is the standard hierarchy:
1 array (
2 'ROLE_ADMIN' =>
3 array (
4 0 => 'ROLE_USER',
5 ),
6 'ROLE_SUPER_ADMIN' =>
7 array (
8 0 => 'ROLE_USER',
9 1 => 'ROLE_ADMIN',
10 2 => 'ROLE_ALLOWED_TO_SWITCH',
11 ),
12 )
Say you have another mechanism for determining a role hierarchy (maybe you retrieve them
from some other configuration file), you can then modify or replace the role hierarchy entirely by
creating a dedicated compiler pass:Parameter patterns 71
1 class EnhanceRoleHierarchyPass implements CompilerPassInterface
2 {
3 public function process(ContainerBuilder $container)
4 {
5 $parameterName = 'security.role_hierarchy.roles';
6 7
$roleHierarchy = $container->getParameter($parameterName);
8 9
// modify the role hierarchy
10 ...
11
12 $container->setParameter($parameterName, $roleHierarchy);
13 }
14 }
Don’t forget to register this compiler pass in your bundle class:
1 class YourBundle extends Bundle
2 {
3 public function build(ContainerBuilder $container)
4 {
5 $container->addCompilerPass(new EnhanceRoleHierarchyPass());
6 }
7 }
Service definition validation
When something is wrong with a service definition, in many cases you will only notice it
when you actually run the application.
To receive warnings about invalid service definitions early on, install the SymfonyServiceDefinitionValidator¹ and enable its compiler pass. From then on, when the service
container is being compiled, you automatically get error messages for any problem that
can be spotted at compile time, like service definitions with non-existing classes or calls to
methods that don’t exist. The validator even recognizes bad constructor arguments.